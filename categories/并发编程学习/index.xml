<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>并发编程学习 - 分类 - yakax</title><link>https://yakax.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</link><description>并发编程学习 - 分类 - yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 29 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" rel="self" type="application/rss+xml"/><item><title>LongAdder学习</title><link>https://yakax.github.io/longadder%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/longadder%E5%AD%A6%E4%B9%A0/</guid><description>&lt;p>&lt;/p></description></item><item><title>并发编程学习(6)CountDownLatch、Semaphore、CyclicBarrier</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A06countdownlatchsemaphorecyclicbarrier/</link><pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A06countdownlatchsemaphorecyclicbarrier/</guid><description><![CDATA[<h3 id="countdownlatch">CountDownLatch</h3>
<p>countdownlatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完毕再执行,countdownlatch 提供了两个方法，一个是 countDown，一个是 await。countdownlatch 初始化的时候需要传入一个整数，在这个整数倒数到 0 之前，调用了 await 方法的程序都必须要等待，然后通过 countDown 来倒数</p>
<h4 id="示例代码">示例代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        new Thread(() -&gt; {
            System.out.println(&#34;Thread1&#34;);
            countDownLatch.countDown(); //3-1=2
            System.out.println(&#34;Thread1执行完毕&#34;);
        }).start();
        new Thread(() -&gt; {
            System.out.println(&#34;Thread2&#34;);
            countDownLatch.countDown();//2-1=1
            System.out.println(&#34;Thread2执行完毕&#34;);
        }).start();
        new Thread(() -&gt; {
            System.out.println(&#34;Thread3&#34;);
            countDownLatch.countDown();//1-1=0
            System.out.println(&#34;Thread3执行完毕&#34;);
        }).start();
        countDownLatch.await();
    }
输出--------------------
Thread1
Thread2
Thread2执行完毕
Thread1执行完毕
Thread3
Thread3执行完毕
-----------不会结束
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>并发编程学习(5)Condition</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A05condition/</link><pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A05condition/</guid><description>&lt;h2 id="condition">Condition&lt;/h2>
&lt;p>在前面学习 synchronized 的时候，有wait/notify 的基本使用，结合 synchronized 可以实现对线程的通信。那么，既然 J.U.C 里面提供了锁的实现机制，那 J.U.C 里面应该也有提供线程通信的机制,Condition 是一个多线程协调通信的工具类，可以让某些线程一起等待某个条件(condition)，只有满足条件时，线程才会被唤醒。&lt;/p></description></item><item><title>并发编程学习(4)Lock</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A04lock/</link><pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A04lock/</guid><description><![CDATA[<h3 id="初步认识juc">初步认识JUC</h3>
<p>Java.util.concurrent 是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如线程池、阻塞队列、计时器、同步器、并发集合等等。并发包的作者是大名鼎鼎的 Doug Lea。</p>
<h3 id="lock">lock</h3>
<p>在 Lock 接口出现之前，Java 中的应用程序对于多线程的并发安全处理只能基于synchronized 关键字来解决。但是 synchronized 在有些场景中会存在一些短板，也就是它并不适合于所有的并发场景。但是在 Java5 以后，Lock 的出现可以解决synchronized 在某些场景中的短板，它比 synchronized 更加灵活。
Lock 本质上是一个接口，它定义了释放锁和获得锁的抽象方法，定义成接口就意味着它定义了锁的一个标准规范，也同时意味着锁的不同实现。实现 Lock 接口的类有很多，以下为几个常见的锁实现</p>
<h4 id="lock接口">Lock接口</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">void lock() // 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放
void lockInterruptibly() // 和lock()方法相似, 但阻塞的线程可中断，抛 出java.lang.InterruptedException 异常
boolean tryLock() // 非阻塞获取锁;尝试获取锁，如果成功返回 true
boolean tryLock(longtimeout, TimeUnit timeUnit)//带有超时时间的获取锁方法
void unlock() // 释放锁
</code></pre></td></tr></table>
</div>
</div><p>类图
<a data-fancybox="gallery" href="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/Concurrent/4/6.png">
    
</a></p>]]></description></item><item><title>并发编程学习(3)线程安全性分析</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A03%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A03%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</guid><description><![CDATA[<h3 id="初步认识-volatile">初步认识 Volatile</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    public /*volatile*/ static boolean stop=false;
    public static void main( String[] args ) throws InterruptedException {
        Thread t1=new Thread(()-&gt;{
            int i=0;
            while(!stop){ 
                i++;
            }
        });
        t1.start();
        Thread.sleep(1000);
        stop=true; //true
    }
</code></pre></td></tr></table>
</div>
</div><ul>
<li>定义一个共享变量 stop</li>
<li>在main线程中创建一个子线程 thread，子线程读取到 stop的值做循环结束的条件</li>
<li>main线程中修改stop的值为 true</li>
<li>当 stop没有增加volatile修饰时，子线程对于主线程的 stop=true的修改是不可见的，这样将导致子线程出现死循环</li>
<li>当 stop增加了volatile修饰时，子线程可以获取到主线程对于 stop=true的值，子线程while循环条件不满足退出循环</li>
</ul>
<p><strong>增加volatile关键字以后，main线程对于共享变量 stop值的更新，对于子线程 thread可见，这就是volatile的作用</strong></p>]]></description></item><item><title>并发编程学习(2)synchronized与锁的唤醒</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A02synchronized%E4%B8%8E%E9%94%81%E7%9A%84%E5%94%A4%E9%86%92/</link><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A02synchronized%E4%B8%8E%E9%94%81%E7%9A%84%E5%94%A4%E9%86%92/</guid><description><![CDATA[<h3 id="synchronized-的基本认识">synchronized 的基本认识</h3>
<p>在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java SE 1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p>
<h3 id="synchronized-的基本语法">synchronized 的基本语法</h3>
<p>synchronized 有三种方式来加锁，分别是</p>
<ol>
<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SyncDemo {
    Object lock = new Object();

    public synchronized void demo1() {

    }

    public void demo2() {
        // TODO
        synchronized (this) {

        }
        // TODO
    }

    public synchronized static void demo3() {

    }

    public void demo4() {
        synchronized (SyncDemo.class) {

        }
    }

    public void demo5() {
        synchronized (lock) {

        }
    }
}
</code></pre></td></tr></table>
</div>
</div><p>不同的修饰类型，代表锁的控制粒度</p>]]></description></item><item><title>并发编程学习(1)线程的创建、启动、停止</title><link>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A01%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2/</link><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A01%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2/</guid><description><![CDATA[<h3 id="单核cpu执行程序的流程">单核cpu执行程序的流程</h3>
<p><a data-fancybox="gallery" href="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/Concurrent/1/2.png">
    
</a></p>
<p><font color=red><strong>有了进程以后，可以让操作系统从宏观层面实现多应用并发。而并发的实现是通过 CPU 时间片不端切换执行的。对于单核 CPU 来说，在任意一个时刻只会有一个进程在被CPU 调度</strong></font></p>]]></description></item></channel></rss>