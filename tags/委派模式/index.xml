<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>委派模式 - 标签 - yakax</title><link>https://yakax.github.io/tags/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F/</link><description>委派模式 - 标签 - yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 21 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.github.io/tags/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml"/><item><title>适配器设计模式</title><link>https://yakax.github.io/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<ol>
<li>已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况</li>
<li>适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案</li>
</ol>]]></description></item><item><title>委派设计模式</title><link>https://yakax.github.io/%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.github.io/%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p><font color=red>委派其实就是静态代理和策略模式一种特殊的组合,因为代理模式注重过程，而委派模式注重结果。</font>
在我们日常开发中的spring mvc中的DispatcherServlet类就是用了委派模式,其原理就是根据用户的url在handlerMapping里面找到对应的处理类,然后委派到具体方法。在 Spring 源码中，只要以 Delegate 结尾的都是实现了委派模式。例如：BeanDefinitionParserDelegate 根据不同类型委派不同的逻辑解析 BeanDefinition。</p>
<p>由于不属于GOF 23种设计模式之一</p>
<ul>
<li>程序当中一般是精简程序逻辑提升代码可读性</li>
</ul>]]></description></item></channel></rss>