<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>MySQL-Explain学习 - yakax</title><meta name=Description content><meta property="og:title" content="MySQL-Explain学习"><meta property="og:description" content="执行计划各列详解"><meta property="og:type" content="article"><meta property="og:url" content="https://yakax.gitee.io/mysql-explain%E5%AD%A6%E4%B9%A0/"><meta property="og:image" content="https://yakax.gitee.io/images/1.png"><meta property="article:published_time" content="2021-01-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-20T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yakax.gitee.io/images/1.png"><meta name=twitter:title content="MySQL-Explain学习"><meta name=twitter:description content="执行计划各列详解"><meta name=application-name content="yakax"><meta name=apple-mobile-web-app-title content="yakax"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:'==document.location.protocol?'https:':'http:')+"//widget.daovoice.io/widget/af744044.js","daovoice")
daovoice('init',{app_id:"af744044"});daovoice('update');</script><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yakax.gitee.io/mysql-explain%E5%AD%A6%E4%B9%A0/><link rel=prev href=https://yakax.gitee.io/mysql-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/><link rel=next href=https://yakax.gitee.io/mysql-buffer-pool-%E5%AD%A6%E4%B9%A0-copy/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"MySQL-Explain学习","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yakax.gitee.io\/mysql-explain%E5%AD%A6%E4%B9%A0\/"},"image":["https:\/\/yakax.gitee.io\/images\/avatar.png"],"genre":"posts","keywords":"MySQL, Explain","wordcount":6544,"url":"https:\/\/yakax.gitee.io\/mysql-explain%E5%AD%A6%E4%B9%A0\/","datePublished":"2021-01-20T00:00:00+00:00","dateModified":"2021-01-20T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"yakax","logo":"https:\/\/yakax.gitee.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yakax"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">MySQL-Explain学习</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>yakax</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/><i class="far fa-folder fa-fw"></i>MySQL性能调优</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-20>2021-01-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6544 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#执行计划各列详解>执行计划各列详解</a><ul><li><a href=#id>id</a></li><li><a href=#select_type>select_type</a></li><li><a href=#table>table</a></li><li><a href=#partitions>partitions</a></li><li><a href=#type-主要关注>type 主要关注</a><ul><li><ul><li><a href=#未使用索引的情况>未使用索引的情况</a></li></ul></li></ul></li><li><a href=#possible_keys和和key--主要关注>possible_keys和和key 主要关注</a></li><li><a href=#key_len>key_len</a></li><li><a href=#ref>ref</a></li><li><a href=#rows>rows</a></li><li><a href=#filtered>filtered</a></li><li><a href=#extra>Extra</a></li></ul></li><li><a href=#查看额外执行计划信息>查看额外执行计划信息</a></li><li><a href=#查看执行计划优化过程>查看执行计划优化过程</a></li></ul></nav></div></div><div class=content id=content><h2 id=执行计划各列详解>执行计划各列详解</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/explain.png!print></p><h3 id=id>id</h3><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表，<strong>每出现一个SELECT关键字，就为它分配一个唯一的id值</strong></p><blockquote><p>比如子查询 可能id就不想同，但查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询，id就相同了。</p></blockquote><h3 id=select_type>select_type</h3><blockquote><p>MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。</p></blockquote><ul><li><p>SIMPLE</p><p>查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型、当然，连接查询也算是SIMPLE类型</p></li><li><p>PRIMARY</p><p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>info_flow</span> <span class=k>UNION</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>info_flow</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/union.png!print></p></li><li><p>UNION</p><p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION</p></li><li><p>UNION RESULT</p><p>MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT</p></li><li><p>SUBQUERY</p><blockquote><p>物化：在SQL执行过程中，第一次需要子查询结果时执行子查询并将子查询的结果保存为临时表，后续对子查询结果集的访问将直接通过临时表获得</p><p>semi-join：只需要满足匹配一张表。半连接</p></blockquote><p>如果包含子查询的查询语句不能够转为对应的semi-join的形式,一般在in语句带子查询时。<strong>并且该子查询是不相关子查询,</strong> 并且查询优化器决定采用将该子查询物化的方案来执行该子查询时。子查询由于会被物化，所以只需要执行一遍</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=k>IN</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>key1</span> <span class=k>FROM</span> <span class=n>s2</span><span class=p>)</span> <span class=k>OR</span> <span class=n>key3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>DEPENDENT SUBQUERY</p><p>如果包含子查询的查询语句不能够转为对应的semi-join的形式，<strong>并且该子查询是相关子查询</strong>，则该子查询的第一个SELECT关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY。需要注意这个查询类型没有被物化，查询可能会被执行多次</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=k>IN</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>key1</span> <span class=k>FROM</span> <span class=n>s2</span> <span class=k>WHERE</span> <span class=n>s1</span><span class=p>.</span><span class=n>key2</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>key2</span><span class=p>)</span> <span class=k>OR</span> <span class=n>key3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>DEPENDENT UNION</p><p>在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=k>IN</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>key1</span> <span class=k>FROM</span> <span class=n>s2</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span> <span class=k>UNION</span> <span class=k>SELECT</span> <span class=n>key1</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>=</span> <span class=s1>&#39;b&#39;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><strong>这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由UNION连起来的两个小查询。</strong></p><p><strong>SELECT key1 FROM s2 WHERE key1 = &lsquo;a&rsquo;这个小查询由于是子查询中第一个查询，所以它的select_type是DEPENDENT SUBQUERY，</strong></p><p><strong>而SELECT key1 FROM s1 WHERE key1 = &lsquo;b&rsquo;这个查询的select_type就是DEPENDENT UNION</strong></p></li><li><p>DERIVED</p><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type就是DERIVED</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>id</span><span class=p>,</span> <span class=nf>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=k>as</span> <span class=n>count</span> <span class=k>FROM</span> <span class=n>info_flow</span> <span class=k>GROUP</span> <span class=k>BY</span> <span class=n>id</span><span class=p>)</span> <span class=k>AS</span> <span class=n>derived_s1</span> <span class=k>where</span> <span class=n>id</span> <span class=o>&gt;</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/derived.png!print></p><p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是<derived2>，表示该查询是针对将派生表物化之后的表进行查询的。</p></li><li><p>MATERIALIZED</p><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type属性就是MATERIALIZED</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>info_flow</span> <span class=k>where</span> <span class=n>area_id</span> <span class=k>in</span><span class=p>(</span><span class=k>SELECT</span> <span class=n>biz_id</span> <span class=k>FROM</span> <span class=n>biz_dispatch_record</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/materilized.png!print></p><p>执行计划的第三条记录的id值为2，说明该条记录对应的是一个单表查询，从它的select_type值为MATERIALIZED可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的id值都为1，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的table列的值是<subquery2>，<strong>说明该表其实就是id为2对应的子查询执行之后产生的物化表，然后将s1和该物化表进行连接查询。</strong></p></li></ul><h3 id=table>table</h3><p><strong>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的</strong>，<font color=red>所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名</font></p><h3 id=partitions>partitions</h3><p>分区</p><h3 id=type-主要关注>type 主要关注</h3><blockquote><p>执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法，其中的type列就表明了这个访问方法是个啥</p><p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了All这个访问方法外，其余的访问方法都能用到索引，除了index_merge访问方法外，其余的访问方法都最多只能用到一个索引。</p></blockquote><ul><li><p>const</p><p>当我们根据<strong>主键</strong>或者<strong>唯一</strong>二级索引列与常数进行等值匹配时，对单表的访问方法就是const。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>eq_ref</p><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（<strong>如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较</strong>），则对该被驱动表的访问方法就是eq_ref</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>INNER</span> <span class=k>JOIN</span> <span class=n>s2</span> <span class=k>ON</span> <span class=n>s1</span><span class=p>.</span><span class=n>id</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>ref</p><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>single_table</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>=</span> <span class=s1>&#39;abc&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>ref_or_null</p><p>对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span> <span class=k>OR</span> <span class=n>key1</span> <span class=k>IS</span> <span class=no>NULL</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>index_merge</p><p><a href=https://yakax.gitee.io/mysql-%e7%b4%a2%e5%bc%95-%e7%b4%a2%e5%bc%95%e5%90%88%e5%b9%b6%e5%ad%a6%e4%b9%a0/ target=_blank rel="noopener noreffer">索引合并</a></p></li><li><p>unique_subquery</p><p>unique_subquery是针对在一些包<strong>含IN子查询的查询语句中</strong>，如果查询优化器决定将IN子查询转换为EXISTS子查询，而且<strong>子查询可以使用到主键进行等值匹配的话</strong>，那么该子查询执行计划的type列的值就是unique_subquery</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key2</span> <span class=k>IN</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>id</span> <span class=k>FROM</span> <span class=n>s2</span> <span class=k>where</span> <span class=n>s1</span><span class=p>.</span><span class=n>key1</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>key1</span><span class=p>)</span> <span class=k>OR</span> <span class=n>key3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>index_subquery</p><p>index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>common_field</span> <span class=k>IN</span> <span class=p>(</span><span class=k>SELECT</span> <span class=n>key3</span> <span class=k>FROM</span> <span class=n>s2</span> <span class=k>where</span> <span class=n>s1</span><span class=p>.</span><span class=n>key1</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>key1</span><span class=p>)</span> <span class=k>OR</span> <span class=n>key3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div></li><li><p>range</p><p>如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=k>IN</span> <span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>);</span>
<span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>&gt;</span> <span class=s1>&#39;a&#39;</span> <span class=k>AND</span> <span class=n>key1</span> <span class=o>&lt;</span> <span class=s1>&#39;b&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p><strong>只要索引列和常数使用=、&lt;=>、IN、NOT IN、IS NULL、IS NOT NULL、>、&lt;、>=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;>）或者LIKE操作符连接起来，就可以产生一个所谓的区间，（LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引）</strong> IN操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样</p><h5 id=未使用索引的情况>未使用索引的情况</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>single_table</span> <span class=k>WHERE</span> <span class=n>key2</span> <span class=o>&gt;</span> <span class=mi>100</span> <span class=k>AND</span> <span class=n>common_field</span> <span class=o>=</span> <span class=s1>&#39;abc&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>这个查询语句中能利用的索引只有idx_key2一个，而idx_key2这个二级索引的记录中又不包含common_field这个字段，所以在使用二级索引idx_key2定位记录的阶段用不到common_field = &lsquo;abc&rsquo;这个条件，这个条件是在回表获取了完整的用户记录后才使用的,而范围区间是为了到索引中取记录中提出的概念，所以在确定范围区间的时候不需要考虑common_field = &lsquo;abc&rsquo;这个条件。</p><p><strong>这也就说说明如果我们强制使用idx_key2执行查询的话，对应的范围区间就是(-∞, +∞)而不是(100, +∞)，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。所以mysql 很可能会直接扫描聚簇索引。</strong></p></li><li><p>index</p><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，也就是要回表时。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql> <span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=n>key_part2</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key_part3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>上述查询中的搜索列表中只有key_part2一个列，而且搜索条件中也只有key_part3一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行ref或者range方式的访问，只能<strong>扫描整个idx_key_part</strong>索引的记录。</p><p>对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，<strong>所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些</strong>。</p></li><li><p>all</p><p>最直接的查询执行方式就是我们已经提了无数遍的<strong>全表扫描</strong>，对于InnoDB表来说也就是直接扫描聚簇索引，设计MySQL的大叔把这种使用全表扫描执行查询的方式称之为：all</p></li></ul><h3 id=possible_keys和和key--主要关注>possible_keys和和key 主要关注</h3><p>possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key列表示实际用到的索引有哪些</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> <span class=n>key1</span> <span class=o>&gt;</span> <span class=s1>&#39;z&#39;</span> <span class=k>AND</span> <span class=n>key3</span> <span class=o>=</span> <span class=s1>&#39;a&#39;</span><span class=p>;</span>
<span class=err>一般情况</span><span class=n>possible_keys列的值是idx_key1</span><span class=p>,</span><span class=n>idx_key3</span><span class=err>。后</span><span class=n>key列的值是其中一个</span><span class=err>：优化器会根据数据量</span> <span class=err>成本来确定用那个索引。</span>
</code></pre></td></tr></table></div></div><h3 id=key_len>key_len</h3><p>key_len列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。</li><li>如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><p>所以一般VARCHAR(100) 可以存储空 就会有303字节</p><h3 id=ref>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<strong>const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery</strong>其中之一时，<strong>ref</strong> 列展示的就是与索引列作等值匹配的东东是个啥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span><span class=o>*</span> <span class=k>FROM</span> <span class=n>lms_clue</span> <span class=k>WHERE</span> <span class=n>phone</span><span class=o>=</span><span class=s1>&#39;15183904781&#39;</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/ref.png!print></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span><span class=o>*</span> <span class=k>FROM</span> <span class=n>lms_clue</span> <span class=n>s1</span> <span class=k>INNER</span> <span class=k>JOIN</span> <span class=n>app_user</span>  <span class=n>s2</span> <span class=k>ON</span> <span class=n>s1</span><span class=p>.</span><span class=n>phone</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>phone</span>
<span class=err>显示具体索引匹配字段</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/refkey.png!print></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span><span class=o>*</span> <span class=k>FROM</span> <span class=n>lms_clue</span> <span class=n>s1</span> <span class=k>INNER</span> <span class=k>JOIN</span> <span class=n>app_user</span>  <span class=n>s2</span> <span class=k>ON</span> <span class=n>s1</span><span class=p>.</span><span class=n>phone</span> <span class=o>=</span> <span class=nf>UPPER</span><span class=p>(</span><span class=n>s2</span><span class=p>.</span><span class=n>phone</span><span class=p>)</span>
<span class=err>显示函数</span><span class=n>func</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/reffunc.png!print></p><h3 id=rows>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数；但这个是预估的 不一定准。</p><h3 id=filtered>filtered</h3><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span><span class=o>*</span> <span class=k>FROM</span> <span class=n>lms_clue</span> <span class=n>s1</span> <span class=k>WHERE</span>  <span class=n>biz_id</span><span class=o>&gt;</span><span class=mi>100000</span> <span class=k>and</span> <span class=n>phone</span> <span class=o>&gt;</span><span class=s1>&#39;15183904781&#39;</span> 
<span class=err>从执行计划可以看出来，满足</span><span class=n>biz_id的记录有231284条</span><span class=err>。执行计划的</span><span class=n>filtered列就代表查询优化器预测在这266条记录中</span><span class=err>，有多少条记</span>
<span class=err>录满足其余的搜索条件，也就是</span><span class=n>phone</span> <span class=o>&gt;</span><span class=s1>&#39;15183904781&#39;</span> <span class=err>这个条件的百分比。此处</span><span class=n>filtered列的值是25</span><span class=p>.</span><span class=mi>00</span><span class=err>。都是预估值</span>

<span class=err>如果是连表查询</span> <span class=err>也就是驱动表与被驱动表的匹配条数。</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/explain/filter.png!print></p><h3 id=extra>Extra</h3><p>这个里面有很多类型，列举一些比较常见的。</p><ul><li><p><strong>No tables used</strong> : 顾名思义 没有表</p></li><li><p><strong>Impossible WHERE</strong>：查询语句的WHERE子句永远为FALSE时将会提示</p></li><li><p><strong>No matching min/max row</strong>：当查询列表处有MIN或者MAX聚集函数，但是并没有符合WHERE子句中的搜索条件的记录时</p><ul><li>EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &lsquo;abcdefg&rsquo;;</li></ul></li><li><p><strong>Using index</strong>：当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下</p></li><li><p><strong>Using index condition</strong>: 其实就是索引条件下推-在索引那篇文章学习过
我们说回表操作其实是一个随机IO，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计MySQL的大叔们把他们的这个改进称之为索引条件下推（英文名：IndexCondition Pushdown）。</p></li><li><p><strong>Using where</strong>: 当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时</p></li><li><p><strong>Using join buffer (Block Nested Loop)</strong>：在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫join buffer的内存块来加快查询速度，也就是我们所讲的基于块的嵌套循环算法&ndash;在连接查询详解文章里面有写。</p></li><li><p><strong>Not exists</strong>: 连接查询时发现where条件与on条件不匹配</p></li><li><p><strong>Using intersect(&mldr;)、Using union(&mldr;)和Using sort_union(&mldr;)</strong>:使用了索引合并</p></li><li><p><strong>Zero limit:</strong> limit 0</p></li><li><p><strong>Using filesort</strong>：排序操作无法在索引上，只能采用内存或者磁盘排序的时候，如果数据量大最好还是优化为按索引顺序排序。、</p></li><li><p><strong>Using temporary</strong>：在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含DISTINCT、GROUP BY、UNION等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。</p><blockquote><p><strong>如果临时表分组了,mysql会默认加上orderby来排序。意味着：你查询某个没索引的字段，并且你要对这个字段分组。那么mysql 会建立临时表并且对记录进行分组排序。如果不想排序。我们需要显式指定order by null 来减少Using filesort这个成本</strong></p></blockquote></li><li><p><strong>Start temporary, End temporary</strong>: 查询优化器会优先尝试将IN子查询转换成semi-join，而semi-join又有好多种执行策略，当执行策略为DuplicateWeedout时，<strong>也就是通过建立临时表来实现为外层查询中的记录进行去重操作时</strong>，驱动表查询执行计划的Extra列将显示Start temporary提示，被驱动表查询执行计划的Extra列将显示End temporary提示</p></li><li><p><strong>LooseScan</strong>：在将In子查询转为semi-join时，如果采用的是LooseScan执行策略</p></li><li><p>FirstMatch(tbl_name)：在将In子查询转为semi-join时，如果采用的是FirstMatch执行策略</p><blockquote><p>semi-join 具体看连接查询篇</p></blockquote></li></ul><h2 id=查看额外执行计划信息>查看额外执行计划信息</h2><p>在我们使用EXPLAIN语句查看了某个查询的执行计划后，紧接着还可以使用SHOW WARNINGS语句查看与这个查询的执行计划有关的一些扩展信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>EXPLAIN</span> <span class=k>SELECT</span><span class=o>*</span> <span class=k>FROM</span> <span class=n>lms_clue</span> <span class=n>s1</span> <span class=k>INNER</span> <span class=k>JOIN</span> <span class=n>app_user</span>  <span class=n>s2</span> <span class=k>ON</span> <span class=n>s1</span><span class=p>.</span><span class=n>phone</span> <span class=o>=</span> <span class=n>s2</span><span class=p>.</span><span class=n>phone</span><span class=p>;</span>
<span class=k>show</span> <span class=n>WARNINGS</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>分别是<strong>Level、Code、Message</strong>。我们最常见的就是Code为1003的信息，当Code值为1003时，Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。</p><p><strong>Message</strong>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，<strong>并不是等价于</strong>，也就是说Message字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解查MySQL将如何执行查询语句的一个参考<strong>依据</strong>而已</p><h2 id=查看执行计划优化过程>查看执行计划优化过程</h2><p>如果要看具体执行计划为什么选择某个索引，我们需要通过optimizer_trace来查看。</p><p>默认<code>optimizer_trace</code> 这个是关闭的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=kt>SET</span> <span class=n>optimizer_trace</span><span class=o>=</span><span class=s2>&#34;enabled=on&#34;</span><span class=p>;</span>

<span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>s1</span> <span class=k>WHERE</span> 
    <span class=n>key1</span> <span class=o>&gt;</span> <span class=s1>&#39;z&#39;</span> <span class=k>AND</span> 
    <span class=n>key2</span> <span class=o>&lt;</span> <span class=mi>1000000</span> <span class=k>AND</span> 
    <span class=n>key3</span> <span class=k>IN</span> <span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>)</span> <span class=k>AND</span> 
    <span class=n>common_field</span> <span class=o>=</span> <span class=s1>&#39;abc&#39;</span><span class=p>;</span>
    
<span class=k>SELECT</span> <span class=o>*</span> <span class=k>FROM</span> <span class=n>information_schema</span><span class=p>.</span><span class=n>OPTIMIZER_TRACE</span><span class=err>\</span><span class=n>G</span>

<span class=c1>## 当你停止查看语句的优化过程时，把optimizer trace功能关闭
</span><span class=c1></span><span class=kt>SET</span> <span class=n>optimizer_trace</span><span class=o>=</span><span class=s2>&#34;enabled=off&#34;</span>
</code></pre></td></tr></table></div></div><p>information_schema数据库下的OPTIMIZER_TRACE表字段有4个</p><ul><li><strong>QUERY</strong>：表示我们的查询语句。</li><li><strong>TRACE</strong>：表示优化过程的JSON格式文本。</li><li><strong>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</strong>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li><strong>INSUFFICIENT_PRIVILEGES</strong>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是1</li></ul><blockquote><p>优化过程大致分为了三个阶段：prepare阶段、optimize阶段、execute阶段</p><p>我们所说的基于成本的优化主要集中在optimize阶段。
对于单表查询来说，我们主要关注optimize阶段的"rows_estimation"这个过程
对于多表连接查询来说，我们更多需要关注"considered_execution_plans"这个过程</p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-20</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/mysql/>MySQL</a>,&nbsp;<a href=/tags/explain/>Explain</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/mysql-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/ class=prev rel=prev title=MySQL-一些问题><i class="fas fa-angle-left fa-fw"></i>MySQL-一些问题</a>
<a href=/mysql-buffer-pool-%E5%AD%A6%E4%B9%A0-copy/ class=next rel=next title="MySQL-Buffer Pool 学习">MySQL-Buffer Pool 学习<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>yakax</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"yakax.blog","id-2":"yakax.blog"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"3MT6GW9D7W","algoliaIndex":"blog","algoliaSearchKey":"41ebe3571ca584723e8648600bbf45ce","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":150,"type":"algolia"},"typeit":{"cursorChar":"_","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":200}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>