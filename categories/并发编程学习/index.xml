<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>并发编程学习 - 分类 - yakax</title><link>https://yakax.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</link><description>并发编程学习 - 分类 - yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 22 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.gitee.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" rel="self" type="application/rss+xml"/><item><title>ConcurrentHashMap源码学习</title><link>https://yakax.gitee.io/concurrenthashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/concurrenthashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h3 id="整体结构图">整体结构图&lt;/h3>
&lt;p>&lt;/p></description></item><item><title>Condition源码学习</title><link>https://yakax.gitee.io/condition%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/condition%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description>&lt;p>总体Condition产生的图&lt;/p>
&lt;p>&lt;/p></description></item><item><title>FutureTask源码学习</title><link>https://yakax.gitee.io/futuretask%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/futuretask%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h4 id="基本属性"><strong>基本属性</strong></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  	<span class="cm">/* Possible state transitions:
</span><span class="cm">     * NEW -&gt; COMPLETING -&gt; NORMAL
</span><span class="cm">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
</span><span class="cm">     * NEW -&gt; CANCELLED
</span><span class="cm">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span> <span class="c1">//线程状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NEW</span>          <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// 进来未执行的状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COMPLETING</span>   <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// 表示正在结束，临时状态，用于结束前cas操作;异常和有结果前都会有
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NORMAL</span>       <span class="o">=</span> <span class="n">2</span><span class="o">;</span> <span class="c1">// 正常结束
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EXCEPTIONAL</span>  <span class="o">=</span> <span class="n">3</span><span class="o">;</span> <span class="c1">// 异常结束
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span>    <span class="o">=</span> <span class="n">4</span><span class="o">;</span> <span class="c1">// 任务被取消
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INTERRUPTING</span> <span class="o">=</span> <span class="n">5</span><span class="o">;</span> <span class="c1">// 中断中 也是临时状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INTERRUPTED</span>  <span class="o">=</span> <span class="n">6</span><span class="o">;</span> <span class="c1">// 已中断
</span><span class="c1"></span>
	<span class="c1">// 运行任务
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">callable</span><span class="o">;</span> 
    <span class="c1">// 整个任务周期中 存放值的对象，会有异常或者正常的值
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">outcome</span><span class="o">;</span> 
    <span class="c1">// 正在执行任务的线程 
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">runner</span><span class="o">;</span>
    <span class="c1">// get任务阻塞的线程 会存在这个队列里面
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">WaitNode</span> <span class="n">waiters</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>ReentrantLock + AQS源码学习</title><link>https://yakax.gitee.io/reentrantlock-aqs%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/reentrantlock-aqs%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<p>ReentrantLock 里面所使用到的基本结构</p>
<p>持有锁的waitstatus 状态 来标识node线程状态</p>
<p><a data-fancybox="gallery" href="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/Concurrent/aqs/QQ%E6%88%AA%E5%9B%BE20200916143206.png">
    
</a></p>]]></description></item><item><title>ThreadPoolExecutor源码学习</title><link>https://yakax.gitee.io/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h4 id="属性字段说明">属性字段说明</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//高3位：表示当前线程池运行状态   除去高3位之后的低位：表示当前线程池中所拥有的线程数量
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="n">RUNNING</span><span class="o">,</span> <span class="n">0</span><span class="o">));</span>
    <span class="c1">//表示在ctl中，低COUNT_BITS位 是用于存放当前线程数量的位。
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNT_BITS</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="n">3</span><span class="o">;</span>
    <span class="c1">//低COUNT_BITS位 所能表达的最大数值。 000 11111111111111111111 =&gt; 5亿多。
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

    <span class="c1">// runState is stored in the high-order bits
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000  转换成整数，其实是一个负数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//000 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="n">0</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//001 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//010 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="n">2</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//011 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="n">3</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>

    <span class="c1">// Packing and unpacking ctl
</span><span class="c1"></span>    <span class="c1">//获取当前线程池运行状态
</span><span class="c1"></span>    <span class="c1">//~000 11111111111111111111 =&gt; 111 000000000000000000000
</span><span class="c1"></span>    <span class="c1">//c == ctl = 111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000000
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>

    <span class="c1">//获取当前线程池线程数量
</span><span class="c1"></span>    <span class="c1">//c == ctl = 111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//000 111111111111111111111
</span><span class="c1"></span>    <span class="c1">//000 000000000000000000111 =&gt; 7
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>

    <span class="c1">//用在重置当前线程池ctl值时  会用到
</span><span class="c1"></span>    <span class="c1">//rs 表示线程池状态   wc 表示当前线程池中worker（线程）数量
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000
</span><span class="c1"></span>    <span class="c1">//000 000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000111
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ctlOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">rs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">wc</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">rs</span> <span class="o">|</span> <span class="n">wc</span><span class="o">;</span> <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>LongAdder源码学习</title><link>https://yakax.gitee.io/longadder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/longadder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description>&lt;p>&lt;/p></description></item><item><title>并发编程学习(6)CountDownLatch、Semaphore、CyclicBarrier</title><link>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A06countdownlatchsemaphorecyclicbarrier/</link><pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A06countdownlatchsemaphorecyclicbarrier/</guid><description><![CDATA[<h3 id="countdownlatch">CountDownLatch</h3>
<p>countdownlatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完毕再执行,countdownlatch 提供了两个方法，一个是 countDown，一个是 await。countdownlatch 初始化的时候需要传入一个整数，在这个整数倒数到 0 之前，调用了 await 方法的程序都必须要等待，然后通过 countDown 来倒数</p>
<h4 id="示例代码">示例代码</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        new Thread(() -&gt; {
            System.out.println(&#34;Thread1&#34;);
            countDownLatch.countDown(); //3-1=2
            System.out.println(&#34;Thread1执行完毕&#34;);
        }).start();
        new Thread(() -&gt; {
            System.out.println(&#34;Thread2&#34;);
            countDownLatch.countDown();//2-1=1
            System.out.println(&#34;Thread2执行完毕&#34;);
        }).start();
        new Thread(() -&gt; {
            System.out.println(&#34;Thread3&#34;);
            countDownLatch.countDown();//1-1=0
            System.out.println(&#34;Thread3执行完毕&#34;);
        }).start();
        countDownLatch.await();
    }
输出--------------------
Thread1
Thread2
Thread2执行完毕
Thread1执行完毕
Thread3
Thread3执行完毕
-----------不会结束
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>并发编程学习(5)Condition</title><link>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A05condition/</link><pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A05condition/</guid><description>&lt;h2 id="condition">Condition&lt;/h2>
&lt;p>在前面学习 synchronized 的时候，有wait/notify 的基本使用，结合 synchronized 可以实现对线程的通信。那么，既然 J.U.C 里面提供了锁的实现机制，那 J.U.C 里面应该也有提供线程通信的机制,Condition 是一个多线程协调通信的工具类，可以让某些线程一起等待某个条件(condition)，只有满足条件时，线程才会被唤醒。&lt;/p></description></item><item><title>并发编程学习(4)Lock</title><link>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A04lock/</link><pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A04lock/</guid><description><![CDATA[<h3 id="初步认识juc">初步认识JUC</h3>
<p>Java.util.concurrent 是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如线程池、阻塞队列、计时器、同步器、并发集合等等。并发包的作者是大名鼎鼎的 Doug Lea。</p>
<h3 id="lock">lock</h3>
<p>在 Lock 接口出现之前，Java 中的应用程序对于多线程的并发安全处理只能基于synchronized 关键字来解决。但是 synchronized 在有些场景中会存在一些短板，也就是它并不适合于所有的并发场景。但是在 Java5 以后，Lock 的出现可以解决synchronized 在某些场景中的短板，它比 synchronized 更加灵活。
Lock 本质上是一个接口，它定义了释放锁和获得锁的抽象方法，定义成接口就意味着它定义了锁的一个标准规范，也同时意味着锁的不同实现。实现 Lock 接口的类有很多，以下为几个常见的锁实现</p>
<h4 id="lock接口">Lock接口</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">void lock() // 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放
void lockInterruptibly() // 和lock()方法相似, 但阻塞的线程可中断，抛 出java.lang.InterruptedException 异常
boolean tryLock() // 非阻塞获取锁;尝试获取锁，如果成功返回 true
boolean tryLock(longtimeout, TimeUnit timeUnit)//带有超时时间的获取锁方法
void unlock() // 释放锁
</code></pre></td></tr></table>
</div>
</div><p>类图
<a data-fancybox="gallery" href="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/Concurrent/4/6.png">
    
</a></p>]]></description></item><item><title>并发编程学习(3)线程安全性分析</title><link>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A03%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A03%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</guid><description><![CDATA[<h3 id="初步认识-volatile">初步认识 Volatile</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    public /*volatile*/ static boolean stop=false;
    public static void main( String[] args ) throws InterruptedException {
        Thread t1=new Thread(()-&gt;{
            int i=0;
            while(!stop){ 
                i++;
            }
        });
        t1.start();
        Thread.sleep(1000);
        stop=true; //true
    }
</code></pre></td></tr></table>
</div>
</div><ul>
<li>定义一个共享变量 stop</li>
<li>在main线程中创建一个子线程 thread，子线程读取到 stop的值做循环结束的条件</li>
<li>main线程中修改stop的值为 true</li>
<li>当 stop没有增加volatile修饰时，子线程对于主线程的 stop=true的修改是不可见的，这样将导致子线程出现死循环</li>
<li>当 stop增加了volatile修饰时，子线程可以获取到主线程对于 stop=true的值，子线程while循环条件不满足退出循环</li>
</ul>
<p><strong>增加volatile关键字以后，main线程对于共享变量 stop值的更新，对于子线程 thread可见，这就是volatile的作用</strong></p>]]></description></item></channel></rss>