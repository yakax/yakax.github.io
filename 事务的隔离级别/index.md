# Spring事务的隔离级别

**spring有5种隔离机制设置 其中数据库有四种隔离级别，而spring 多的那种就是默认设置数据库隔离设置，下面主要讲讲这些隔离机制的区别**

<img src="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/2018-11-5/9.png" />

<!--more-->
#### 数据库的四种隔离级别
1. 读未提交(Read Uncommitted)：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。
2. 读已提交(Read Committed)：允许不可重复读取，但不允许脏读取。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
2. 可重复读(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻影数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务
4. 序列化(Serializable)：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。


#### 默认Isolation.DEFAULT
> 使用后端数据库默认的隔离级别，MySQL默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别。

#### Isolation.READ_UNCOMMITTED
> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读

#### Isolation.READ_COMMITTED
> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

#### Isolation.REPEATABLE_READ
> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

#### Isolation.SERIALIZABLE
> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

一般项目中会采用默认的保证数据的4大特性（原子性、一致性、隔离性、持久性），在一定的业务情况下根据需求设置事务来保证数据的正确。



