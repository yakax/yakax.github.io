<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>设计模式 - 分类 - yakax</title><link>https://yakax.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>设计模式 - 分类 - yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 24 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml"/><item><title>各类设计模式对比与Spring设计模式的总结</title><link>https://yakax.gitee.io/%E5%90%84%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8Espring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%90%84%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8Espring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93/</guid><description><![CDATA[<p>{% raw %}</p>
<table>
  <tr>
    <th width=10%>分类</th>
    <th>设计模式</th>
  </tr>
  <tr>
    <td>创建型</td>
    <td>工厂方法模式(Factory Method)、抽象工厂模式(Abstract Factory)、建造者模式(Builder)、原型模式(Prototype)、单例模式(Singleton)</td>
  </tr>
  <tr>
    <td>结构型</td>
    <td>适配器模式(Adapter)、桥接模式(Bridge)、组合模式(Composite)、装饰器模式(Decorator)、门面模式(Facade)、享元模式(Flyweight)、代理模式(Proxy)</td>
  </tr>
  <tr>
    <td>行为型</td>
    <td>解释器模式(Interpreter)、模板方法模式(Template Method)、责任链模式(Chain of Responsibility)、命令模式(Command)、迭代器模式(Iterator)、调解者模式(Mediator)、备忘录模式(Memento)、观察者模式(Observer)、状态模式(State)、策略模式(Strategy)、访问者模式(Visitor)</td>
  </tr>
</table>
{% endraw %}]]></description></item><item><title>观察设计模式</title><link>https://yakax.gitee.io/%E8%A7%82%E5%AF%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E8%A7%82%E5%AF%9F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<ol>
<li>观察者模式有时也叫做发布订阅模式。</li>
<li>主要用于在关联行为之间建立一套触发机制的场景(例如一些提醒业务、MQ等等)</li>
<li>java.awt.Event 就是观察者模式的一种，只不过 Java 很少被用来写桌面程序。上面的比如点击事件等等都是通过发布订阅绑定来触发事件。</li>
<li>在spring 中ContextLoaderListener是实现了ServletContextListener接口,这个接口也是继承的EventListener。这也是观察者模式的代表。</li>
</ol>]]></description></item><item><title>装饰设计模式</title><link>https://yakax.gitee.io/%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<ol>
<li>用于扩展一个类的功能或给一个类添加附加职责</li>
<li>动态的给一个对象添加功能，这些功能可以再动态的撤销</li>
<li>在spring mvc中 HttpHeadResponseDecorator类就是使用的装饰者</li>
<li>在mybatis中(org.apache.ibatis.cache.Cache)里面就有许多关于缓存的装饰者类(后续我会在mybatis源码分析里面看)。</li>
<li>在jdk中io相关的类(比如InputStream)都是使用了装饰设计模式。</li>
</ol>]]></description></item><item><title>适配器设计模式</title><link>https://yakax.gitee.io/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<ol>
<li>已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况</li>
<li>适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案</li>
</ol>]]></description></item><item><title>委派设计模式</title><link>https://yakax.gitee.io/%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%A7%94%E6%B4%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p><font color=red>委派其实就是静态代理和策略模式一种特殊的组合,因为代理模式注重过程，而委派模式注重结果。</font>
在我们日常开发中的spring mvc中的DispatcherServlet类就是用了委派模式,其原理就是根据用户的url在handlerMapping里面找到对应的处理类,然后委派到具体方法。在 Spring 源码中，只要以 Delegate 结尾的都是实现了委派模式。例如：BeanDefinitionParserDelegate 根据不同类型委派不同的逻辑解析 BeanDefinition。</p>
<p>由于不属于GOF 23种设计模式之一</p>
<ul>
<li>程序当中一般是精简程序逻辑提升代码可读性</li>
</ul>]]></description></item><item><title>模板设计模式</title><link>https://yakax.gitee.io/%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p>定义一个模板结构，将具体内容延迟到子类去实现,<font color=red>在不改变模板结构的前提下在子类中重新定义模板中的内容。</font>
比如JDBC；</p>
<h4 id="优点">优点</h4>
<ul>
<li>提高代码复用性
将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中</li>
<li>实现了反向控制
通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 &amp; 符合“开闭原则”</li>
</ul>
<h4 id="缺点">缺点</h4>
<p>引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。</p>]]></description></item><item><title>策略设计模式</title><link>https://yakax.gitee.io/%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p>一个系统需要动态地在几种算法中选择一种的情况</p>
<h4 id="优点">优点</h4>
<ol>
<li>易于扩展, 增加一个新的策略只需要添加一个具体的策略类即可,基本不需要改变原有的代码,<font color=red>符合开闭原则;</font></li>
<li>避免使用多重条件选择语句(if else),充分体现面向对象设计思想。</li>
</ol>]]></description></item><item><title>代理设计模式</title><link>https://yakax.gitee.io/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p>为其他对象提供一种代理以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。
<font color=red>关键:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象;这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法;</font></p>
<h4 id="静态代理">静态代理</h4>
<h5 id="说明">说明</h5>
<p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.
<font color=red>关键：在编译期确定代理对象，在程序运行前代理类的.class文件就已经存在了。</font></p>]]></description></item><item><title>原型设计模式</title><link>https://yakax.gitee.io/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p>原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。
所谓原型模式，就是 Java 中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原
型对象的特点，效率高（<font color=red>避免了重新执行构造过程步骤,而且实例的创建开销比较大或者需要输入较多参数</font>）。</p>
<h4 id="浅克隆">浅克隆</h4>
<h5 id="说明">说明</h5>
<p>浅复制仅仅复制所克隆的对象，而不复制它所引用的对象。 Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址</p>]]></description></item><item><title>七大设计原则</title><link>https://yakax.gitee.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</link><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</guid><description><![CDATA[<h4 id="单一职责原则single-responsibility-principle简称srp-">单一职责原则（Single Responsibility Principle，简称SRP ）</h4>
<ul>
<li><strong>核心思想</strong>：应该有且仅有一个原因引起类的变更</li>
<li><strong>问题描述</strong>：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。</li>
<li><strong>好处</strong>：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险</li>
<li><strong>需注意</strong>：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</li>
</ul>]]></description></item></channel></rss>