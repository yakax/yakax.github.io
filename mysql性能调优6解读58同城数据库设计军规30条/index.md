# MySQL性能调优(6)解读58同城数据库设计军规30条


>军规适用场景：并发量大、数据量大的互联网业务
<font color=red>只是解读：没必要完全效仿</font>

#### 基础规范
1. 必须使用InnoDB存储引擎
**解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高**
2. 必须使用UTF8字符集不过现在基本上用 UTF8MB4
**解读：万国码，无需转码，无乱码风险，节省空间 UTF8MB4支持图像兼容4字节 **
3. 数据表、数据字段必须加入中文注释
**解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的**
4. 禁止使用存储过程、视图、触发器、Event
**解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧** <font color=red>划重点：面试遇到要做存储过程的公司还是走了吧</font>
5. 禁止存储大文件或者大照片
**解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统或者存云服务也行，数据库里存URI多好**
<!--more-->

#### 命名规范（这个知道就好）
6. 只允许使用内网域名，而不是ip连接数据库
7. 库名、表名、字段名：小写，下划线风格，不超过32个字符,必须见名知意，禁止拼音英文混用。
8. 表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx
9. 线上环境、开发环境、测试环境数据库内网域名遵循命名规范
<font color=red>这个根据公司要求，只要人员能轻易区分数据库名称</font>
```
业务名称：xxx
线上环境：dj.xxx.db
开发环境：dj.xxx.rdb
测试环境：dj.xxx.tdb
从库在名称后加-s标识，备库在名称后加-ss标识
线上从库：dj.xxx-s.db
线上备库：dj.xxx-sss.db
```
#### 表设计规范
10. 单实例表数目必须小于500
11. 单表列数目必须小于30
12. 表必须有主键，例如自增主键
```
主键递增,数据行写入可以提高插入性能,可以避免page分裂,减少表碎片提升空间和内存的使用
主键要选择较短的数据类型,Innodb引擎普通索引都会保存主键的值,较短的数据类型可以有效的减少索引的磁盘空间,提高索引的缓存效率
无主键的表删除，在row模式的主从架构，会导致备库夯住
```
13. 禁止使用外键(现在一般都建立逻辑外键)，如果有外键完整性约束，需要应用程序控制
**解读：：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先**

#### 字段设计规范
14. 必须把字段定义为NOT NULL并且提供默认值
```
null的列使索引/索引统计/值比较都更加复杂,对MySQL来说更难优化
null 这种类型MySQL内部需要进行特殊处理,增加数据库处理记录的复杂性;
同等条件下,表中有较多空字段的时候,数据库的处理性能会降低很多
null值需要更多的存储空间,无论是表还是索引中每行中的 对null的处理时候,只能采用is null或is not null,而不能采用=、in、<>、!=
not in这些操作符号如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录
```
15. 禁止使用TEXT、BLOB类型
**解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能**
16. 禁止使用小数存储货币
**解读：使用整数吧，小数容易导致钱对不上**
17. 必须使用varchar(20)存储手机号
**解读：涉及到区号或者国家代号，可能出现+-()
    手机号不会去做数学运算,所以请别弄成int类型
    varchar可以支持模糊查询，例如：like“138%”**
18. 禁止使用ENUM，可使用TINYINT代替
**解读：增加新的ENUM值要做DDL操作
    ENUM的内部实际存储就是整数，你以为自己定义的是字符串？**
    
#### 索引设计规范
19. 单表索引建议控制在5个以内
20. 单索引字段数不允许超过5个
**解读：字段超过5个时，实际已经起不到有效过滤数据的作用了**
21. 禁止在更新十分频繁、区分度不高的属性上建立索引
**离散性原因（离散性太差,优化器可能都不会走索引）
更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能
“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似**
22. 建立组合索引，必须把区分度高的字段放在前面
**解读：能够更加有效的过滤数据（其中有离散性原因和最左匹配原则的原因）**

#### SQL使用规范
23. 禁止使用SELECT *，只获取必要的字段，需要显示说明列属性
**解读：读取不需要的列会增加CPU、IO、NET消耗、并且不能有效的利用覆盖索引**
24. 禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性
**解读：容易在增加或者删除字段后出现程序BUG**
25. 禁止使用属性隐式转换
**解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描并且把phone字段转换成int类型来，而不能命中phone索引**
26. 禁止在WHERE条件的属性上使用函数或者表达式
<font color=red>这个非常重要</font>
**解读：SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-02-15' 会导致全表扫描
正确的写法是：SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-02-15 00:00:00')**
27. 禁止负向查询，以及%开头的模糊查询
**解读：负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，会导致全表扫描，在b+tree中在不确定情况下不知道走那条索引、%开头的模糊查询，会导致全表扫描，不走索引**
28. 禁止大表使用JOIN查询，禁止大表使用子查询
**解读：连接查询在表多(一般3个)的或者大数据量情况下会非常慢(因为大数据量进行笛卡尔积的匹对,会耗费很多内存进行中间结果计算)并且不利于维护表结构：这样就应该在应用层做join拆分成单表查询
子查询会产生临时表，消耗较多内存与CPU，极大影响数据库性能**
这里引申出一个老师给我的答案：非常感谢Alex老师 
```
子查询会产生临时表效率低，效率低体现在两方面:
一、因为要产生临时表，所以空间复杂度很高，硬盘IO也很大；
二、因为是嵌套查询，所以时间复杂度也很高。查询算法的好坏要从空间复杂度和时间复杂度两个角度来思考。
JOIN查询有两个特点:
一、它的时间复杂度和嵌套查询是一样的，都是乘法级别的时间复杂度，举个例子，两张100条数据的表，两张表的join查询在
时间复杂度方面就相当于是查一张有10000条数据的表。如果是大表，一张表有1亿条数据，乘法级别的时间复杂度是很难想象的。
二、再来说说空间复杂度:子查询会产生临时表，并不代表JOIN查询就一定不会产生像临时表一样的东西，大多数的JOIN查询不
会产生像临时表一样的东西，这是因为数据量小，工作内存很够用。想像一下，两张有1亿条数据的表，把数据全部导到内存中，
然后进行条件查询比对，如果MySQL真的这样做，那么它可以改名叫redis缓存了。它的本质是硬盘数据库，不是缓存，所以数据量大时，
临时文件也一定要存在硬盘。也就是说，如果是JOIN查询的是大表，其实和你想像的大表子查询在过程方面是没有本质区别的。
这不光是58的军规，很多企业都是这样的，领导没有时间和每一个程序员去分析查询算法的空间复杂度与时间复杂度，所以才定军规。
```
29. 禁止使用OR条件，必须改为IN查询
**解读：旧版本MySQL的OR查询是不能命中索引的,即使能命中索引,为何要让数据库耗费更多的CPU帮助实施查询优化呢？
in 的查询算法是类似于二分法查找,条件在多的情况下效率肯定要比or好**
30. 应用程序必须捕获SQL异常，并有相应处理
**总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟！所以你出问题了要有相应的处理并且方便维护，及时“查漏补缺”**















