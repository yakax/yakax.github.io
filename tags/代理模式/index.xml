<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>代理模式 - 标签 - yakax</title><link>https://yakax.gitee.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><description>代理模式 - 标签 - yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 01 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.gitee.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml"/><item><title>代理设计模式</title><link>https://yakax.gitee.io/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[<h4 id="应用场景">应用场景</h4>
<p>为其他对象提供一种代理以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。
<font color=red>关键:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象;这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法;</font></p>
<h4 id="静态代理">静态代理</h4>
<h5 id="说明">说明</h5>
<p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.
<font color=red>关键：在编译期确定代理对象，在程序运行前代理类的.class文件就已经存在了。</font></p>]]></description></item></channel></rss>