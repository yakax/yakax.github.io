<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>MySQL-锁-间隙锁案例篇 - yakax</title><meta name=Description content><meta property="og:title" content="MySQL-锁-间隙锁案例篇"><meta property="og:description" content="间隙加锁规则

原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。"><meta property="og:type" content="article"><meta property="og:url" content="https://yakax.github.io/mysql-%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E6%A1%88%E4%BE%8B%E7%AF%87/"><meta property="og:image" content="https://yakax.github.io/images/1.png"><meta property="article:published_time" content="2021-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yakax.github.io/images/1.png"><meta name=twitter:title content="MySQL-锁-间隙锁案例篇"><meta name=twitter:description content="间隙加锁规则

原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。"><meta name=application-name content="yakax"><meta name=apple-mobile-web-app-title content="yakax"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:'==document.location.protocol?'https:':'http:')+"//widget.daovoice.io/widget/af744044.js","daovoice")
daovoice('init',{app_id:"af744044"});daovoice('update');</script><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yakax.github.io/mysql-%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E6%A1%88%E4%BE%8B%E7%AF%87/><link rel=prev href=https://yakax.github.io/longadder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/><link rel=next href=https://yakax.github.io/mysql-%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"MySQL-锁-间隙锁案例篇","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yakax.github.io\/mysql-%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E6%A1%88%E4%BE%8B%E7%AF%87\/"},"image":["https:\/\/yakax.github.io\/images\/avatar.png"],"genre":"posts","keywords":"MySQL, 间隙锁案例","wordcount":6535,"url":"https:\/\/yakax.github.io\/mysql-%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E6%A1%88%E4%BE%8B%E7%AF%87\/","datePublished":"2021-01-03T00:00:00+00:00","dateModified":"2021-01-03T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"yakax","logo":"https:\/\/yakax.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yakax"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">MySQL-锁-间隙锁案例篇</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>yakax</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/><i class="far fa-folder fa-fw"></i>MySQL性能调优</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-03>2021-01-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6535 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#间隙加锁规则>间隙加锁规则</a></li><li><a href=#案例sql>案例SQL</a></li><li><a href=#案例1-等值查询间隙锁>案例1-等值查询间隙锁</a></li><li><a href=#案例2-非唯一索引等值锁>案例2-非唯一索引等值锁</a></li><li><a href=#案例3主键索引范围锁>案例3：主键索引范围锁</a></li><li><a href=#案例4非唯一索引范围锁>案例4：非唯一索引范围锁</a></li><li><a href=#案例5唯一索引范围锁bug>案例5：唯一索引范围锁bug</a></li><li><a href=#案例6非唯一索引上存在等值的例子>案例6：非唯一索引上存在"等值"的例子</a></li><li><a href=#案例7limit-语句加锁>案例7：limit 语句加锁</a></li><li><a href=#案例8一个死锁的例子>案例8：一个死锁的例子</a></li><li><a href=#案例9order-by改变加锁方向>案例9：order by改变加锁方向</a></li><li><a href=#案例10再次分析范围查询>案例10：再次分析范围查询</a></li><li><a href=#怎么查看死锁>怎么查看死锁</a></li><li><a href=#怎么看锁等待>怎么看锁等待</a></li><li><a href=#update间隙锁变大的例子>update间隙锁变大的例子</a></li><li><a href=#kill锁住的线程>kill锁住的线程</a><ul><li><a href=#长时间没返回>长时间没返回</a></li><li><a href=#行锁>行锁</a></li><li><a href=#小总结>小总结</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=间隙加锁规则>间隙加锁规则</h2><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><blockquote><p><strong>注意！有行</strong>才会加行锁。如果查询条件没有命中行，那就加next-key lock。当然，等值判断的时候，需要加上优化2</p><p>（即：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。）</p><p>&lt;=到底是间隙锁还是行锁？其实，这个问题，你要跟“执行过程”配合起来分析。
<strong>在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；</strong>
<strong>找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。</strong></p></blockquote><h2 id=案例sql>案例SQL</h2><p>所有案例都是在可重复读隔离级别(repeatable-read)下验证的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-MYSQL data-lang=MYSQL><span class=k>CREATE</span> <span class=k>TABLE</span> <span class=o>`</span><span class=n>t</span><span class=o>`</span> <span class=p>(</span>
  <span class=o>`</span><span class=n>id</span><span class=o>`</span> <span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span> <span class=k>NOT</span> <span class=no>NULL</span><span class=p>,</span>
  <span class=o>`</span><span class=n>c</span><span class=o>`</span> <span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span> <span class=k>DEFAULT</span> <span class=no>NULL</span><span class=p>,</span>
  <span class=o>`</span><span class=n>d</span><span class=o>`</span> <span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span> <span class=k>DEFAULT</span> <span class=no>NULL</span><span class=p>,</span>
  <span class=k>PRIMARY</span> <span class=k>KEY</span> <span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span>
  <span class=k>KEY</span> <span class=o>`</span><span class=n>c</span><span class=o>`</span> <span class=p>(</span><span class=o>`</span><span class=n>c</span><span class=o>`</span><span class=p>)</span>
<span class=p>)</span> <span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span>

<span class=k>insert</span> <span class=k>into</span> <span class=n>t</span> <span class=k>values</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>),(</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>),</span>
<span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>),(</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>),(</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>),(</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><h2 id=案例1-等值查询间隙锁>案例1-等值查询间隙锁</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock1.png!print style=zoom:33%></p><blockquote><p>由于表t中没有id=7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><p>所以，session B要往这个间隙里面插入id=8的记录会被锁住，但是session C修改id=10这行是可以的。</p></blockquote><h2 id=案例2-非唯一索引等值锁>案例2-非唯一索引等值锁</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock2.png!print style=zoom:33%></p><p>这里session A要给索引c上c=5的这一行加上读锁。</p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li><strong>要注意c是普通索引</strong>，因此仅访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li></ol><p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p><p><strong>在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p><p><strong>这个例子说明,锁是加在索引上的,</strong> 同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。</p><p><strong>所以，如果一个select * from &mldr; for update 语句，优化器决定使用全表扫描，那么就会把主键索引上next-key lock全加上。</strong></p><h2 id=案例3主键索引范围锁>案例3：主键索引范围锁</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=n>mysql</span><span class=o>&gt;</span> <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>id</span><span class=o>=</span><span class=mi>10</span> <span class=k>for</span> <span class=k>update</span><span class=p>;</span>
<span class=n>mysql</span><span class=o>&gt;</span> <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>id</span><span class=o>&gt;=</span><span class=mi>10</span> <span class=k>and</span> <span class=n>id</span><span class=o>&lt;</span><span class=mi>11</span> <span class=k>for</span> <span class=k>update</span><span class=p>;</span>
<span class=err>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock3.png!print style=zoom:33%></p><ol><li>开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。</li><li><strong>范围查找就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]。</strong></li></ol><blockquote><p>session A这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]。这样，session B和session C的结果你就能理解了。</p><p>这里需要注意一点，首次session A定位查找id=10的行的时候，是当做等值查询来判断的，而向右扫描到id=15的时候，用的是范围查询判断。</p></blockquote><h2 id=案例4非唯一索引范围锁>案例4：非唯一索引范围锁</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock4.png!print style=zoom:33%></p><p><strong>session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock</strong>。</p><blockquote><p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p><p>这里需要扫描到c=15才停止扫描，是合理的，因为InnoDB要扫到c=15，才知道不需要继续往后找了。</p></blockquote><h2 id=案例5唯一索引范围锁bug>案例5：唯一索引范围锁bug</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock5.png!print style=zoom:33%></p><p><strong>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了。但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</strong></p><blockquote><p>所以你看到了，session B要更新id=20这一行，是会被锁住的。同样地，session C要插入id=16的一行，也会被锁住。</p><p>照理说，这里锁住id=20这一行的行为，其实是没有必要的。因为扫描到id=15,就可以确定不用往后再找了,但实现上还是这么做了</p></blockquote><h2 id=案例6非唯一索引上存在等值的例子>案例6：非唯一索引上存在"等值"的例子</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>insert</span> <span class=k>into</span> <span class=n>t</span> <span class=k>values</span><span class=p>(</span><span class=mi>30</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>30</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/next6.png!print style=zoom:33%></p><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock6.png!print style=zoom:33%></p><p>这时，session A在遍历的时候，先访问第一个c=10的记录。同样地，根据原则1，这里加的是(c=5,id=5)到(c=10,id=10)这个next-key lock。然后，session A向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10) 到 (c=15,id=15)的间隙锁。</p><p><strong>所以最后加锁就是（5,5) 到（15,15）之间</strong> 即(c=5,id=5)和(c=15,id=15)这两行上都没有锁。</p><h2 id=案例7limit-语句加锁>案例7：limit 语句加锁</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock7.png!print style=zoom:33%></p><p>session A的delete语句加了 limit 2。你知道表t里c=10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c=10, id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><blockquote><p>因此，索引c上的加锁范围就变成了从（c=5,id=5)到（c=10,id=30)这个前开后闭区间；</p></blockquote><h2 id=案例8一个死锁的例子>案例8：一个死锁的例子</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock8.png!print style=zoom:33%></p><p>现在，我们按时间顺序来分析一下为什么是这样的结果。</p><ol><li>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</li><li>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</li><li>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</li></ol><p><strong>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的。</strong> 也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h2 id=案例9order-by改变加锁方向>案例9：order by改变加锁方向</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock9.png!print style=zoom:33%></p><ol><li>由于是order by c desc，第一个要定位的是索引c上“最右边的”c=20的行，所以会加上间隙锁(20,25)和next-key lock (15,20]。</li><li>在索引c上向左遍历，要扫描到c=10才停下来，所以next-key lock会加到(5,10]，这正是阻塞session B的insert语句的原因。</li><li>在扫描过程中，c=20、c=15、c=10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。</li></ol><p>因此，session A 的select语句锁的范围就是：<strong>索引c上 (5, 25)；主键索引上id=10、15、20三个行锁。</strong></p><p><font color=red>这里在说明一下！锁就是加在索引上的，这是InnoDB的一个基础设定，需要你在分析问题的时候要一直记得。</font></p><h2 id=案例10再次分析范围查询>案例10：再次分析范围查询</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=n>begin</span><span class=p>;</span>
<span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>id</span><span class=o>&gt;</span><span class=mi>9</span> <span class=k>and</span> <span class=n>id</span><span class=o>&lt;</span><span class=mi>12</span> <span class=k>order</span> <span class=k>by</span> <span class=n>id</span> <span class=k>desc</span> <span class=k>for</span> <span class=k>update</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。也就是说，id=15这一行，并没有被加上行锁</p><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/next10.png!print style=zoom:33%></p><p>我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退<strong>化为了间隙锁</strong> (10, 15)。</p><ol><li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock (0,5]。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=n>begin</span><span class=p>;</span>
<span class=k>select</span> <span class=n>id</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>c</span> <span class=k>in</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>10</span><span class=p>)</span> <span class=k>lock</span> <span class=k>in</span> <span class=n>share</span> <span class=n>mode</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextexplan.png!print style=zoom:33%></p><ol><li>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。</li><li>同样的，执行c=10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。4</li><li>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。</li></ol><p>需要注意的 <code>select id from t where c in(5,20,10) order by c desc for update;</code> <strong>间隙锁虽然不互斥间隙锁，但是细化到记录上还是会出现互斥的。问题是in条件的加锁时一个个去扫描的。所以两个sql语句在并发时有可能会出现死锁</strong></p><h2 id=怎么查看死锁>怎么查看死锁</h2><blockquote><p>下面是间隙锁案例10出现死锁情况</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>在出现死锁后，执行show engine innodb status命令得到的部分输出。这个命令会输出很多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/slock.png!print style=zoom:33%></p><ol><li>这个结果分成三部分：<ul><li>TRANSACTION，是第一个事务的信息；</li><li>TRANSACTION，是第二个事务的信息；</li><li>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。</li></ul></li><li>第一个事务的信息中：<ul><li>WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；</li><li>index c of table <code>test</code>.<code>t</code>，说明在等的是表t的索引c上面的锁；</li><li>lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；</li><li>Record lock说明这是一个记录锁；</li><li>n_fields 2表示这个记录是两列，也就是字段c和主键字段id；</li><li>0: len 4; hex 0000000a; asc ;;是第一个字段，也就是c。值是十六进制a，也就是10；</li><li>1: len 4; hex 0000000a; asc ;;是第二个字段，也就是主键id，值也是10；</li><li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。</li><li>第一个事务信息就只显示出了等锁的状态，在等待(c=10,id=10)这一行的锁。</li><li>当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，我们从第二个事务的信息中推导出来。</li></ul></li><li>第二个事务显示的信息要多一些：<ul><li>“ HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁；</li><li>index c of table <code>test</code>.<code>t</code> 表示锁是在表t的索引c上；</li><li>hex 0000000a和hex 00000014表示这个事务持有c=10和c=20这两个记录锁；</li><li>WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c=5,id=5)这个记录锁。</li></ul></li></ol><p>从上面这些信息中，我们就知道：</p><ol><li>“lock in share mode”的这条语句，持有c=5的记录锁，在等c=10的锁；</li><li>“for update”这个语句，持有c=20和c=10的记录锁，在等c=5的记录锁。</li></ol><p>因此导致了死锁。这里，我们可以得到两个结论：</p><ol><li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</li><li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句，来回滚。</li></ol><h2 id=怎么看锁等待>怎么看锁等待</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/lockwait.png!print style=zoom:33%></p><p><strong>可以看到，由于session A并没有锁住c=10这个记录，所以session B删除id=10这一行是可以的。但是之后，session B再想insert id=10这一行回去就不行了。</strong></p><p><code>show engine innodb status</code></p><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/lockwait1.png!print style=zoom:50%></p><ol><li>index PRIMARY of table <code>test</code>.<code>t</code> ，表示这个语句被锁住是因为表t主键上的某个锁。</li><li>lock_mode X locks gap before rec insert intention waiting 这里有几个信息：<ul><li>insert intention表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，你可以认为它就是这个插入动作本身。</li><li>gap before rec 表示这是一个间隙锁，而不是记录锁。</li></ul></li><li>那么这个gap是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。</li><li>n_fields 5也表示了，这一个记录有5列：<ul><li>0: len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id=15。所以，这时我们就知道了，这个间隙就是id=15之前的，因为id=10已经不存在了，它表示的就是(5,15)。</li><li>1: len 6; hex 000000000513; asc ;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。</li><li>2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看到，这里的acs后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。</li><li>后面两列是c和d的值，都是15。</li></ul></li></ol><p><font color=red>因此，我们就知道了，由于delete操作把id=10这一行删掉了，原来的两个间隙(5,10)、(10,15）变成了一个(5,15)。</font></p><p><strong>session A执行完select语句后，什么都没做，但它加锁的范围突然“变大”了；</strong></p><p>当我们执行select * from t where c>=15 and c&lt;=20 order by c desc lock in share mode; 向左扫描到c=10的时候，要把(5, 10]锁起来。</p><p><strong>也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的</strong>。</p><h2 id=update间隙锁变大的例子>update间隙锁变大的例子</h2><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextupdata.png!print style=zoom:33%></p><p>session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和(25,suprenum]。</p><p>之后session B的第一个update语句，要把c=5改成c=1，你可以理解为两步：</p><ol><li>插入(c=1, id=5)这个记录；</li><li>删除(c=5, id=5)这个记录。</li></ol><p>按照我们上面说的，索引c上(5,10)间隙是由这个间隙右边的记录。所以通过这个操作，session A间隙锁范围变成下层</p><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/trx/nextlock11.png!print style=zoom:33%></p><p>接下来session B要执行 update t set c = 5 where c = 1这个语句了，一样地可以拆成两步：</p><ol><li><strong>插入(c=5, id=5)这个记录；</strong></li><li>删除(c=1, id=5)这个记录。</li></ol><p><strong>第一步尝试在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。</strong></p><h2 id=kill锁住的线程>kill锁住的线程</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql> <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=c1># 长时间没返回
</span></code></pre></td></tr></table></div></div><p><strong>分析语句之前 都应该执行<code>show processlist;查看</code> 后续操作找到了blocking_id kill掉</strong></p><h3 id=长时间没返回>长时间没返回</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=err>如果</span><span class=p>:</span><span class=n>performance_schema</span><span class=o>=</span><span class=k>on</span> <span class=err>打开着可以通过</span><span class=n>select</span> <span class=n>blocking_pid</span> <span class=k>from</span> <span class=n>sys</span><span class=p>.</span><span class=n>schema_table_lock_waits</span><span class=p>;</span> 
</code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/lock/showprocesslist.png!print></p><h3 id=行锁>行锁</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql> <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=n>sys</span><span class=p>.</span><span class=n>innodb_lock_waits</span> <span class=k>where</span> <span class=n>locked_table</span><span class=o>=`</span><span class=s1>&#39;test&#39;</span><span class=p>.</span><span class=s1>&#39;t&#39;</span>
 <span class=c1>## 查询指定表里面的情况
</span></code></pre></td></tr></table></div></div><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/mysql/lock/lock.png!print></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-mysql data-lang=mysql><span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>t</span> <span class=k>where</span> <span class=n>c</span><span class=o>=</span><span class=mi>5</span> <span class=k>for</span> <span class=k>update</span>
<span class=err>当级别为</span><span class=n>RR时</span><span class=err>，是可以解决幻读的，此时对于每条记录的间隙还要加上</span><span class=n>GAP锁</span><span class=err>。也就是说，表上每一条记录和每一个间隙都锁上了。</span>
<span class=err>但是实际上</span> <span class=n>innodb先锁全表的所有行</span> <span class=err>返回</span><span class=n>server层</span><span class=p>,</span><span class=n>InnoDB就会把不满足条件的行行锁去掉</span><span class=err>。所以语句执行完只会锁</span><span class=n>c</span><span class=o>=</span><span class=mi>5</span><span class=err>的行。</span>
</code></pre></td></tr></table></div></div><h3 id=小总结>小总结</h3><ol><li><p>表锁是主动在SQL 上面加的</p></li><li><p>MDL锁时自动加比如改变表结构</p></li><li><p><strong>如果在一个事务内，更新的数据条数过多。建议分开更新，因为在你事务开启时，其他session的查询都会查找你的undo log链条，如果你的链条太长会导致很慢</strong>。</p></li><li><p>(DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁)</p><blockquote><p>增删改查，或者修改表之类的语句都会申请MDL锁，而增删改查 会自动加上MDL读锁。修改表会加上写锁</p></blockquote></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-03</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/mysql/>MySQL</a>,&nbsp;<a href=/tags/%E9%97%B4%E9%9A%99%E9%94%81%E6%A1%88%E4%BE%8B/>间隙锁案例</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/longadder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/ class=prev rel=prev title=LongAdder源码学习><i class="fas fa-angle-left fa-fw"></i>LongAdder源码学习</a>
<a href=/mysql-%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/ class=next rel=next title=MySQL-锁的学习>MySQL-锁的学习<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>yakax</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://fastly.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"yakax.blog","id-2":"yakax.blog"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"3MT6GW9D7W","algoliaIndex":"blog","algoliaSearchKey":"41ebe3571ca584723e8648600bbf45ce","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":150,"type":"algolia"},"typeit":{"cursorChar":"_","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":200}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>