<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>yakax</title><link>https://yakax.gitee.io/</link><description>yakax</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yakax1569@gmail.com (yakax)</managingEditor><webMaster>yakax1569@gmail.com (yakax)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 22 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yakax.gitee.io/index.xml" rel="self" type="application/rss+xml"/><item><title>ConcurrentHashMap源码学习</title><link>https://yakax.gitee.io/concurrenthashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/concurrenthashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h3 id="整体结构图">整体结构图&lt;/h3>
&lt;p>&lt;/p></description></item><item><title>FutureTask源码学习</title><link>https://yakax.gitee.io/futuretask%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/futuretask%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h4 id="基本属性"><strong>基本属性</strong></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  	<span class="cm">/* Possible state transitions:
</span><span class="cm">     * NEW -&gt; COMPLETING -&gt; NORMAL
</span><span class="cm">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
</span><span class="cm">     * NEW -&gt; CANCELLED
</span><span class="cm">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span> <span class="c1">//线程状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NEW</span>          <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">// 进来未执行的状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COMPLETING</span>   <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// 表示正在结束，临时状态，用于结束前cas操作;异常和有结果前都会有
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NORMAL</span>       <span class="o">=</span> <span class="n">2</span><span class="o">;</span> <span class="c1">// 正常结束
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EXCEPTIONAL</span>  <span class="o">=</span> <span class="n">3</span><span class="o">;</span> <span class="c1">// 异常结束
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span>    <span class="o">=</span> <span class="n">4</span><span class="o">;</span> <span class="c1">// 任务被取消
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INTERRUPTING</span> <span class="o">=</span> <span class="n">5</span><span class="o">;</span> <span class="c1">// 中断中 也是临时状态
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INTERRUPTED</span>  <span class="o">=</span> <span class="n">6</span><span class="o">;</span> <span class="c1">// 已中断
</span><span class="c1"></span>
	<span class="c1">// 运行任务
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">callable</span><span class="o">;</span> 
    <span class="c1">// 整个任务周期中 存放值的对象，会有异常或者正常的值
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">outcome</span><span class="o">;</span> 
    <span class="c1">// 正在执行任务的线程 
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">runner</span><span class="o">;</span>
    <span class="c1">// get任务阻塞的线程 会存在这个队列里面
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">WaitNode</span> <span class="n">waiters</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>ReentrantLock + AQS源码学习</title><link>https://yakax.gitee.io/reentrantlock-aqs%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/reentrantlock-aqs%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<p>ReentrantLock 里面所使用到的基本结构</p>
<p>持有锁的waitstatus 状态 来标识node线程状态</p>
<p><a data-fancybox="gallery" href="https://yakax.oss-cn-hangzhou.aliyuncs.com/blog/Concurrent/aqs/QQ%E6%88%AA%E5%9B%BE20200916143206.png">
    
</a></p>]]></description></item><item><title>ThreadPoolExecutor源码学习</title><link>https://yakax.gitee.io/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link><pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h4 id="属性字段说明">属性字段说明</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//高3位：表示当前线程池运行状态   除去高3位之后的低位：表示当前线程池中所拥有的线程数量
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="n">RUNNING</span><span class="o">,</span> <span class="n">0</span><span class="o">));</span>
    <span class="c1">//表示在ctl中，低COUNT_BITS位 是用于存放当前线程数量的位。
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNT_BITS</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="n">3</span><span class="o">;</span>
    <span class="c1">//低COUNT_BITS位 所能表达的最大数值。 000 11111111111111111111 =&gt; 5亿多。
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

    <span class="c1">// runState is stored in the high-order bits
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000  转换成整数，其实是一个负数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//000 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="n">0</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//001 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//010 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="n">2</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
    <span class="c1">//011 000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="n">3</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>

    <span class="c1">// Packing and unpacking ctl
</span><span class="c1"></span>    <span class="c1">//获取当前线程池运行状态
</span><span class="c1"></span>    <span class="c1">//~000 11111111111111111111 =&gt; 111 000000000000000000000
</span><span class="c1"></span>    <span class="c1">//c == ctl = 111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000000
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000000
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>

    <span class="c1">//获取当前线程池线程数量
</span><span class="c1"></span>    <span class="c1">//c == ctl = 111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000111
</span><span class="c1"></span>    <span class="c1">//000 111111111111111111111
</span><span class="c1"></span>    <span class="c1">//000 000000000000000000111 =&gt; 7
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span>

    <span class="c1">//用在重置当前线程池ctl值时  会用到
</span><span class="c1"></span>    <span class="c1">//rs 表示线程池状态   wc 表示当前线程池中worker（线程）数量
</span><span class="c1"></span>    <span class="c1">//111 000000000000000000
</span><span class="c1"></span>    <span class="c1">//000 000000000000000111
</span><span class="c1"></span>    <span class="c1">//111 000000000000000111
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ctlOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">rs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">wc</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">rs</span> <span class="o">|</span> <span class="n">wc</span><span class="o">;</span> <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>MySQL-Buffer Pool 学习</title><link>https://yakax.gitee.io/mysql-buffer-pool-%E5%AD%A6%E4%B9%A0-copy/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-buffer-pool-%E5%AD%A6%E4%B9%A0-copy/</guid><description><![CDATA[<h4 id="一条sql执行基本流程">一条sql执行基本流程</h4>
<p></p>
<blockquote>
<p>在老版本的MySQL中sql通过连接进来时会有查询缓存这一块的逻辑。</p>
<p>查询解析器解析sql 是否正确后，然后基本优化sql，生成执行计划，选择引擎执行。</p>
<p>而InnoDB 在执行时 为了保证对数据的执行更快，省去磁盘IO开销 引入了Buffer Pool</p>
</blockquote>]]></description></item><item><title>MySQL-Explain学习</title><link>https://yakax.gitee.io/mysql-explain%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-explain%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h2 id="执行计划各列详解">执行计划各列详解&lt;/h2>
&lt;p>&lt;/p></description></item><item><title>MySQL-一些问题</title><link>https://yakax.gitee.io/mysql-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid><description><![CDATA[<h4 id="优化器未使用你想用的索引">优化器未使用你想用的索引</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">force</span> <span class="k">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">where</span> <span class="n">a</span> <span class="k">between</span> <span class="mi">10000</span> <span class="k">and</span> <span class="mi">20000</span><span class="p">;</span>
<span class="o">//</span> <span class="err">利用参数</span><span class="n">force</span> <span class="k">index</span>
</code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>MySQL-事务学习</title><link>https://yakax.gitee.io/mysql-%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h2 id="多事务并发处理数据产生的问题">多事务并发处理数据产生的问题</h2>
<p><strong>脏读脏写 都是因为读取了事务未提交时的事务回滚情况</strong></p>
<h4 id="脏写">脏写</h4>
<p>事务A与事务B同时更新一条数据，由于其中一个事务回滚 导致另外事务执行成功的数据不存在了。</p>
<h4 id="脏读">脏读</h4>
<p>事务A还没提交事务时事务B拿到值做了大量的操作，事务A回滚后出现的数据异常问题。</p>
<h4 id="不可重复读-与可重复读">不可重复读 与可重复读</h4>
<p>事务A修改了值并且提交了事务    B读取到   然后B在执行事务期间 C又修改了值并且提交了。这时B读取到的值又变了。 这就时不可重复读问题。 可重复读就相反 并且读取到的值是相同的。</p>
<h4 id="幻读">幻读</h4>
<p>其实就是在事务执行期间第二次查询相比第一次查询出现了之前没出现过的数据。</p>]]></description></item><item><title>MySQL-成本与统计数据学习</title><link>https://yakax.gitee.io/mysql-%E6%88%90%E6%9C%AC%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-%E6%88%90%E6%9C%AC%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<blockquote>
<p>MySQL执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询</p>
</blockquote>
<h2 id="基于成本的优化步骤">基于成本的优化步骤</h2>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">single_table</span> <span class="p">(</span>
    <span class="n">id</span> <span class="kt">INT</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">key1</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">key2</span> <span class="kt">INT</span><span class="p">,</span>
    <span class="n">key3</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">key_part1</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">key_part2</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">key_part3</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">common_field</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="nf">idx_key1</span> <span class="p">(</span><span class="n">key1</span><span class="p">),</span>
    <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="nf">idx_key2</span> <span class="p">(</span><span class="n">key2</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="nf">idx_key3</span> <span class="p">(</span><span class="n">key3</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="nf">idx_key_part</span><span class="p">(</span><span class="n">key_part1</span><span class="p">,</span> <span class="n">key_part2</span><span class="p">,</span> <span class="n">key_part3</span><span class="p">)</span>
<span class="p">)</span> <span class="kp">Engine</span><span class="o">=</span><span class="n">InnoDB</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
<span class="c1">## 执行sql语句
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">single_table</span> <span class="k">WHERE</span> 
    <span class="n">key1</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span> <span class="k">AND</span> 
    <span class="n">key2</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">AND</span> <span class="n">key2</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="k">AND</span> 
    <span class="n">key3</span> <span class="o">&gt;</span> <span class="n">key2</span> <span class="k">AND</span> 
    <span class="n">key_part1</span> <span class="k">LIKE</span> <span class="s1">&#39;%hello%&#39;</span> <span class="k">AND</span>
    <span class="n">common_field</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span><span class="p">;</span>
<span class="c1">## possible keys只有idx_key1和idx_key2。
</span></code></pre></td></tr></table>
</div>
</div>]]></description></item><item><title>MySQL-日志学习</title><link>https://yakax.gitee.io/mysql-%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://yakax.gitee.io/mysql-%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h2 id="更新语句的基本流程">更新语句的基本流程</h2>
<p></p>
<ol>
<li>更新数据前 会把数据写入uodo 日志文件</li>
<li>更新数据后 会把数据写入redo缓冲池，这意味着这个缓冲池落地磁盘，跟事务有关系，可以通过<code>innodb_flush_log_at_trx_commit </code>配置。</li>
<li>当参数是1时，就是必须把redo log写入磁盘才能提交事务。0 的时候就是不会有redo日志、2 的时候是先写oscache  这两种都有丢失数据的风险</li>
<li>buffer pool就是我们一直在操作的数据的缓冲区。</li>
<li>redo log 文件里面也是一块一块追加在一起的</li>
</ol>]]></description></item></channel></rss>