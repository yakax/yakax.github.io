<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>ThreadLocal源码学习 - yakax</title><meta name=Description content><meta property="og:title" content="ThreadLocal源码学习"><meta property="og:description" content="基本结构图片"><meta property="og:type" content="article"><meta property="og:url" content="https://yakax.github.io/threadlocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"><meta property="og:image" content="https://yakax.github.io/images/1.png"><meta property="article:published_time" content="2021-01-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-22T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yakax.github.io/images/1.png"><meta name=twitter:title content="ThreadLocal源码学习"><meta name=twitter:description content="基本结构图片"><meta name=application-name content="yakax"><meta name=apple-mobile-web-app-title content="yakax"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:'==document.location.protocol?'https:':'http:')+"//widget.daovoice.io/widget/af744044.js","daovoice")
daovoice('init',{app_id:"af744044"});daovoice('update');</script><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://yakax.github.io/threadlocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/><link rel=prev href=https://yakax.github.io/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/><link rel=next href=https://yakax.github.io/synchronousqueue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"ThreadLocal源码学习","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yakax.github.io\/threadlocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/"},"image":["https:\/\/yakax.github.io\/images\/avatar.png"],"genre":"posts","keywords":"ThreadLocal","wordcount":4118,"url":"https:\/\/yakax.github.io\/threadlocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/","datePublished":"2021-01-22T00:00:00+00:00","dateModified":"2021-01-22T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"yakax","logo":"https:\/\/yakax.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"yakax"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=yakax><span class=header-title-pre><i class="fas fa-crosshairs fa-sm"></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a class=menu-item href=https://github.com/yakax title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">ThreadLocal源码学习</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>yakax</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/><i class="far fa-folder fa-fw"></i>并发编程学习</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-22>2021-01-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4118 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#基本结构图片>基本结构图片</a></li><li><a href=#oom-问题>OOM 问题</a></li><li><a href=#源码分析>源码分析</a><ul><li><a href=#弱引用结构情况>弱引用结构情况</a></li><li><a href=#set>set</a></li><li><a href=#set创建新值>set创建新值</a></li><li><a href=#set替换值逻辑>set替换值逻辑</a></li><li><a href=#setfont-colorblue替换过期数据font>set<font color=blue>替换过期数据</font></a></li><li><a href=#set抹除过期数据段-探测式清理>set抹除过期数据段-探测式清理</a></li><li><a href=#set启发式清理>set启发式清理</a></li><li><a href=#get-与初始化threadlocalmap>get 与初始化ThreadLocalMap</a></li><li><a href=#get快速查询>get快速查询</a></li><li><a href=#get快速查询失败>get快速查询失败</a></li><li><a href=#resize扩容>resize()扩容</a></li><li><a href=#remove>remove()</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h3 id=基本结构图片>基本结构图片</h3><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/ThreadLocal/1.png!print style=zoom:25%></p><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/ThreadLocal/2.png!print style=zoom:25%></p><ol><li>每个Thread 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 key 是 <code>ThreadLocal</code>实例本身，value 是真正需要存储的 Object<strong>所以<code>ThreadLocal</code>只有key的引用在 每个线程里面</strong></li><li>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 key 来让线程从 <code>ThreadLocalMap</code> 获取 value</li><li>真正存数据的是Thread 的局部变量 threadLocals 的ThreadLocalMap里面的entry对象的value</li></ol><h3 id=oom-问题>OOM 问题</h3><p>当ThreadLocal被回收 key的引用就消失了，key是弱引用，所以在gc时会被回收，但是里面的值一直绑定到线程本身没回收。如果使用的线程可以一直复用，那么数据就会一直在线程的threadLocals。所以在调用完要<strong>remove</strong>。</p><p><strong>本身ThreadLocal也在规避这种问题，在做操作时都会利用线性探测、启发式清理，删除key为空的信息。</strong></p><p>本身线程结束 其实也是能被回收的，主要是怕线程池，Thread.ThreadLocals会一直存在，占用内存，并且没有调用<strong>remove</strong>方法去规避。<strong>就是上图的连线没了 但是 线程一直没退出</strong></p><blockquote><p>Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value</p></blockquote><p>但是有一点要肯定的是，只要线程没退出,里面entry就有可能不会被回收，那么就可能造成泄漏。<strong>因为实际存储的数据不在threadLocal 而是在线程中。</strong></p><h3 id=源码分析>源码分析</h3><h4 id=弱引用结构情况>弱引用结构情况</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm>* WeakReference 就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。
</span><span class=cm>* 当threadLocal对象失去强引用且对象GC回收后，
</span><span class=cm>* 散列表中的与 threadLocal对象相关联的 entry#key 拿到的是null。
</span><span class=cm>* 站在map角度就可以区分出哪些entry是过期的，哪些entry是非过期的。
</span><span class=cm>* 我觉得 这样至少保证了ThreadLocal 不会内存泄漏
</span><span class=cm>* entry里面的值通过调用set、get、remove的时候会被清除,会尽量删除 这样也会跟着线程的生命周期共存
</span><span class=cm>*/</span>
<span class=kd>static</span> <span class=kd>class</span> <span class=nc>Entry</span> <span class=kd>extends</span> <span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;&gt;</span> <span class=o>{</span>
            <span class=cm>/** The value associated with this ThreadLocal. */</span>
            <span class=n>Object</span> <span class=n>value</span><span class=o>;</span>

            <span class=n>Entry</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span><span class=o>,</span> <span class=n>Object</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
                <span class=kd>super</span><span class=o>(</span><span class=n>k</span><span class=o>);</span>
                <span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=set>set</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=n>T</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
        <span class=c1>// 是否存在关联的值
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=c1>// 替换
</span><span class=c1></span>            <span class=n>map</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
        <span class=k>else</span>
            <span class=c1>// 创建
</span><span class=c1></span>            <span class=n>createMap</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
    <span class=o>}</span>

</code></pre></td></tr></table></div></div><h4 id=set创建新值>set创建新值</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>        <span class=n>ThreadLocalMap</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>firstKey</span><span class=o>,</span> <span class=n>Object</span> <span class=n>firstValue</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 设置默认长度 16 entry
</span><span class=c1></span>            <span class=n>table</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>[</span><span class=n>INITIAL_CAPACITY</span><span class=o>];</span>

            <span class=c1>// 通过 每个TheadLocal 独有的 nextHashCode 算出应该存放的位置
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>firstKey</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>INITIAL_CAPACITY</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
            <span class=c1>// 以每个TheadLocal为key 存放值为传进来的
</span><span class=c1></span>            <span class=n>table</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>firstKey</span><span class=o>,</span> <span class=n>firstValue</span><span class=o>);</span>
            <span class=c1>// 长度1
</span><span class=c1></span>            <span class=n>size</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
            <span class=c1>// 设置扩容阈值
</span><span class=c1></span>            <span class=n>setThreshold</span><span class=o>(</span><span class=n>INITIAL_CAPACITY</span><span class=o>);</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=set替换值逻辑>set替换值逻辑</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>

            <span class=c1>// We don&#39;t use a fast path as with get() because it is at
</span><span class=c1></span>            <span class=c1>// least as common to use set() to create new entries as
</span><span class=c1></span>            <span class=c1>// it is to replace existing ones, in which case, a fast
</span><span class=c1></span>            <span class=c1>// path would fail more often than not.
</span><span class=c1></span>            <span class=c1>// 拿到值 长度 算出 下标
</span><span class=c1></span>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>

            <span class=c1>// 向后查找
</span><span class=c1></span>            <span class=c1>// 因为当前下标找不到 很可能是产生了 冲突了 会向后存放值
</span><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span> <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>)])</span> <span class=o>{</span>
                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
                <span class=c1>// key相等 替换
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
                    <span class=k>return</span><span class=o>;</span>
                <span class=o>}</span>
                <span class=c1>//条件成立：说明 向下寻找过程中 碰到key == null 的情况了，说明当前entry 引用没有了 是过期数据。
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                    <span class=c1>//  替换过期数据的逻辑。
</span><span class=c1></span>                    <span class=n>replaceStaleEntry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
                    <span class=k>return</span><span class=o>;</span>
                <span class=o>}</span>
            <span class=o>}</span>

            <span class=c1>//执行到这里，说明for循环碰到了 slot == null 的情况。
</span><span class=c1></span>            <span class=c1>//在合适的slot中 创建一个新的entry对象。
</span><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
            <span class=c1>// 增加size
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>sz</span> <span class=o>=</span> <span class=o>++</span><span class=n>size</span><span class=o>;</span>
            <span class=c1>//做一次启发式清理
</span><span class=c1></span>            <span class=c1>//条件一：!cleanSomeSlots(i, sz) 成立，说明启发式清理工作 未清理到任何数据..
</span><span class=c1></span>            <span class=c1>//条件二：sz &gt;= threshold 成立，说明当前table内的entry已经达到扩容阈值了..会触发rehash操作。
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(!</span><span class=n>cleanSomeSlots</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>sz</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>sz</span> <span class=o>&gt;=</span> <span class=n>threshold</span><span class=o>)</span>
                <span class=n>rehash</span><span class=o>();</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=setfont-colorblue替换过期数据font>set<font color=blue>替换过期数据</font></h4><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/ThreadLocal/3.png!print style=zoom:50%></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kt>void</span> <span class=nf>replaceStaleEntry</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>,</span>
                                       <span class=kt>int</span> <span class=n>staleSlot</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=n>Entry</span> <span class=n>e</span><span class=o>;</span>
            <span class=c1>// 传进来的 数据应该 放的下标
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>slotToExpunge</span> <span class=o>=</span> <span class=n>staleSlot</span><span class=o>;</span>
            <span class=c1>//条件成立：说明向前找到了过期数据，更新 探测清理过期数据的开始下标为 i
</span><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>prevIndex</span><span class=o>(</span><span class=n>staleSlot</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span> <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>i</span> <span class=o>=</span> <span class=n>prevIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>))</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                    <span class=n>slotToExpunge</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>

            <span class=c1>//以当前staleSlot向后去查找，直到碰到null为止。
</span><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>staleSlot</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
                 <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
                 <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>))</span> <span class=o>{</span>
                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>

                <span class=c1>// key相同 替换操作
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
                    <span class=c1>//替换值
</span><span class=c1></span>                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
                    <span class=c1>//交换位置的逻辑..
</span><span class=c1></span>                    <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>];</span>
                    <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>

                    <span class=c1>// Start expunge at preceding stale entry if it exists
</span><span class=c1></span>                    <span class=c1>// 如果之前的slotToExpunge 改变过 说明 当前下边前面出现过 过期数据
</span><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>slotToExpunge</span> <span class=o>==</span> <span class=n>staleSlot</span><span class=o>)</span>
                        <span class=n>slotToExpunge</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
                    <span class=c1>// expungeStaleEntry(slotToExpunge) 从过期数据开始 做一次探测式数据回收 传入下标
</span><span class=c1></span>                    <span class=c1>//cleanSomeSlots ：启发式清理
</span><span class=c1></span>                    <span class=n>cleanSomeSlots</span><span class=o>(</span><span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>slotToExpunge</span><span class=o>),</span> <span class=n>len</span><span class=o>);</span>
                    <span class=k>return</span><span class=o>;</span>
                <span class=o>}</span>

                <span class=c1>//条件1：k == null 成立，说明当前遍历的entry是一个过期数据..
</span><span class=c1></span>                <span class=c1>//条件2：slotToExpunge == staleSlot 成立，一开始时 的向前查找过期数据 并未找到过期的entry.
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>slotToExpunge</span> <span class=o>==</span> <span class=n>staleSlot</span><span class=o>)</span>
                    <span class=c1>//因为向后查询过程中查找到一个过期数据了，更新slotToExpunge 为 当前位置。
</span><span class=c1></span>                    <span class=c1>//前提条件是 前驱扫描时 未发现 过期数据..
</span><span class=c1></span>                    <span class=n>slotToExpunge</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
            <span class=o>}</span>

            <span class=c1>//什么时候执行到这里呢？
</span><span class=c1></span>            <span class=c1>//向后查找过程中 并未发现 k == key 的entry，说明当前set操作 是一个添加逻辑..
</span><span class=c1></span>            <span class=c1>//直接将新数据添加到 table[staleSlot] 对应的slot中。
</span><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>].</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>

            <span class=c1>// If there are any other stale entries in run, expunge them
</span><span class=c1></span>            <span class=c1>// 如果向后查找发现有过期key 再次清理
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>slotToExpunge</span> <span class=o>!=</span> <span class=n>staleSlot</span><span class=o>)</span>
                <span class=n>cleanSomeSlots</span><span class=o>(</span><span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>slotToExpunge</span><span class=o>),</span> <span class=n>len</span><span class=o>);</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=set抹除过期数据段-探测式清理>set抹除过期数据段-探测式清理</h4><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/ThreadLocal/4.png!print style=zoom:50%></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 抹除过期数据段
</span><span class=c1></span><span class=kd>private</span> <span class=kt>int</span> <span class=nf>expungeStaleEntry</span><span class=o>(</span><span class=kt>int</span> <span class=n>staleSlot</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 拿到数据 和长度
</span><span class=c1></span>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>

            <span class=c1>// expunge entry at staleSlot
</span><span class=c1></span>            <span class=c1>// 使下标对应的value 为空 并且整个 entry 也为空
</span><span class=c1></span>            <span class=c1>//  help gc
</span><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>].</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
            <span class=c1>// 元素个数-1
</span><span class=c1></span>            <span class=n>size</span><span class=o>--;</span>

            <span class=c1>// Rehash until we encounter null
</span><span class=c1></span>            <span class=n>Entry</span> <span class=n>e</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>i</span><span class=o>;</span>
            <span class=c1>//for循环从 下标位置 + 1的位置开始搜索过期数据，直到碰到 Entry == null 结束。
</span><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>staleSlot</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span> <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>))</span> <span class=o>{</span>
                <span class=c1>// Entry 肯定不为空
</span><span class=c1></span>                <span class=c1>// 返回 ThreadLocal key
</span><span class=c1></span>                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
                <span class=c1>// 如果是过期数据 就置空 help gc
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                    <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                    <span class=n>size</span><span class=o>--;</span>
                <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
                    <span class=c1>// 说明数据没过期 重新算位置
</span><span class=c1></span>                    <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>k</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
                    <span class=c1>// 说明 下标位置不是最初算的位置，出现过冲突
</span><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
                        <span class=c1>//将entry当前位置 设置为null
</span><span class=c1></span>                        <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

                        <span class=c1>// Unlike Knuth 6.4 Algorithm R, we must scan until
</span><span class=c1></span>                        <span class=c1>// null because multiple entries could have been stale.
</span><span class=c1></span>                        <span class=c1>//以正确位置 开始放，向后查找第一个 可以存放entry的位置。
</span><span class=c1></span>                        <span class=k>while</span> <span class=o>(</span><span class=n>tab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
                            <span class=n>h</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
                        <span class=n>tab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                    <span class=o>}</span>
                <span class=o>}</span>
            <span class=o>}</span>
            <span class=c1>// 返回最后null 的entry 的下标
</span><span class=c1></span>            <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=set启发式清理>set启发式清理</h4><p><img src=https://yakax-version2.oss-cn-chengdu.aliyuncs.com/blog/ThreadLocal/5.png!print style=zoom:50%></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 启发式清理
</span><span class=c1></span>	<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>cleanSomeSlots</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
            <span class=kt>boolean</span> <span class=n>removed</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=k>do</span> <span class=o>{</span>
                <span class=c1>// i下标的值 肯定是null值  实际形成一个环绕式的访问。
</span><span class=c1></span>                <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
                <span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
                <span class=c1>// 如果entry不为空但是 key 为空 说明ThreadLocal被回收了
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                    <span class=c1>//重新更新n为 table数组长度
</span><span class=c1></span>                    <span class=n>n</span> <span class=o>=</span> <span class=n>len</span><span class=o>;</span>
                    <span class=c1>// 标记被清理过
</span><span class=c1></span>                    <span class=n>removed</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
                    <span class=c1>// 以当前下标为空开始 再次做探测式清理工作
</span><span class=c1></span>                    <span class=n>i</span> <span class=o>=</span> <span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
                <span class=o>}</span>
                <span class=c1>// 假设table长度为16  目的还是为了 多做几次清理
</span><span class=c1></span>                <span class=c1>// 16 &gt;&gt;&gt; 1 ==&gt; 8
</span><span class=c1></span>                <span class=c1>// 8 &gt;&gt;&gt; 1 ==&gt; 4
</span><span class=c1></span>                <span class=c1>// 4 &gt;&gt;&gt; 1 ==&gt; 2
</span><span class=c1></span>                <span class=c1>// 2 &gt;&gt;&gt; 1 ==&gt; 1
</span><span class=c1></span>                <span class=c1>// 1 &gt;&gt;&gt; 1 ==&gt; 0
</span><span class=c1></span>            <span class=o>}</span> <span class=k>while</span> <span class=o>(</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;&gt;&gt;=</span> <span class=n>1</span><span class=o>)</span> <span class=o>!=</span> <span class=n>0</span><span class=o>);</span>
            <span class=k>return</span> <span class=n>removed</span><span class=o>;</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=get-与初始化threadlocalmap>get 与初始化ThreadLocalMap</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>T</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
        <span class=c1>// 获取当前线程
</span><span class=c1></span>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
        <span class=c1>// 根据线程去获取线程的ThreadLocalMap 局部变量
</span><span class=c1></span>        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 不等于null说明已经存在
</span><span class=c1></span>            <span class=c1>// 获取当前ThreadLocal 关联当前线程 ThreadLocalMap.entry
</span><span class=c1></span>            <span class=n>ThreadLocalMap</span><span class=o>.</span><span class=na>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>map</span><span class=o>.</span><span class=na>getEntry</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                <span class=c1>// 存在就返回
</span><span class=c1></span>                <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
                <span class=n>T</span> <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>T</span><span class=o>)</span><span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
                <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=c1>// 有可能map未初始化 或者 map里面没有关联的值
</span><span class=c1></span>        <span class=c1>// 初始化的工作  一般返回默认值
</span><span class=c1></span>        <span class=k>return</span> <span class=n>setInitialValue</span><span class=o>();</span>
    <span class=o>}</span>
 <span class=kd>private</span> <span class=n>T</span> <span class=nf>setInitialValue</span><span class=o>()</span> <span class=o>{</span>
        <span class=c1>// 获取默认值 一般是null 重写过后自定义
</span><span class=c1></span>        <span class=c1>// 类似 ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 99);
</span><span class=c1></span>        <span class=n>T</span> <span class=n>value</span> <span class=o>=</span> <span class=n>initialValue</span><span class=o>();</span>
        <span class=c1>// 获取当前线程 并拿到关联信息
</span><span class=c1></span>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
        <span class=c1>// 通过当前线程 获取map
</span><span class=c1></span>        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
        <span class=c1>// 记住 这里的key 都是当前ThreadLocal 对象
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=c1>// 不等于null 就替换默认值
</span><span class=c1></span>            <span class=n>map</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
        <span class=k>else</span>
            <span class=c1>// 转件新的ThreadLocalMap
</span><span class=c1></span>            <span class=n>createMap</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
    <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=get快速查询>get快速查询</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=n>Entry</span> <span class=nf>getEntry</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
           <span class=c1>// 根据 threadLocal 算出下标
</span><span class=c1></span>           <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>table</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
           <span class=c1>// 拿到entry
</span><span class=c1></span>           <span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
           <span class=c1>// 如果值存在 并且 key相同则可以返回
</span><span class=c1></span>           <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span>
               <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
           <span class=k>else</span>
               <span class=c1>//有几种情况会执行到这里？
</span><span class=c1></span>               <span class=c1>//1.e == null
</span><span class=c1></span>               <span class=c1>//2.e.key != key
</span><span class=c1></span>               <span class=c1>// 发生冲突 值会向后存放
</span><span class=c1></span>               <span class=k>return</span> <span class=n>getEntryAfterMiss</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
       <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=get快速查询失败>get快速查询失败</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>		<span class=cm>/**
</span><span class=cm>         * @param  key the thread local object  threadLocal
</span><span class=cm>         * @param  i the table index for key&#39;s hash code 下标
</span><span class=cm>         * @param  e the entry at table[i]    下标对应的值
</span><span class=cm>         * @return the entry associated with key, or null if no such
</span><span class=cm>         */</span>
        <span class=kd>private</span> <span class=n>Entry</span> <span class=nf>getEntryAfterMiss</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=n>Entry</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=c1>// 不等于null说明值存在 但是 key可能不同
</span><span class=c1></span>            <span class=k>while</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                <span class=c1>// 拿到key
</span><span class=c1></span>                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span>
                    <span class=c1>// key相同就返回
</span><span class=c1></span>                    <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
                <span class=c1>// 说明对应的threadLocal已经没了  因为key 是弱引用
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                    <span class=c1>// 做一次探测式数据回收 传入下标   todo 这是在get数据时发现key为空的时候
</span><span class=c1></span>                    <span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
                <span class=k>else</span>
                    <span class=c1>// 出现冲突 向后查找并再次循环 查找值
</span><span class=c1></span>                    <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
                <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
            <span class=o>}</span>
            <span class=c1>// 未找到
</span><span class=c1></span>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=resize扩容>resize()扩容</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kt>void</span> <span class=nf>resize</span><span class=o>()</span> <span class=o>{</span>
            <span class=c1>//获取当前散列表
</span><span class=c1></span>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>oldTab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=c1>//获取当前散列表长度
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>oldLen</span> <span class=o>=</span> <span class=n>oldTab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=c1>//计算出扩容后的表大小  oldLen * 2
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>newLen</span> <span class=o>=</span> <span class=n>oldLen</span> <span class=o>*</span> <span class=n>2</span><span class=o>;</span>
            <span class=c1>//创建一个新的散列表
</span><span class=c1></span>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>newTab</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>[</span><span class=n>newLen</span><span class=o>];</span>
            <span class=c1>//表示新table中的entry数量。
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>

            <span class=c1>//遍历老表 迁移数据到新表。
</span><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>oldLen</span><span class=o>;</span> <span class=o>++</span><span class=n>j</span><span class=o>)</span> <span class=o>{</span>
                <span class=c1>//访问老表的指定位置的slot
</span><span class=c1></span>                <span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>oldTab</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
                <span class=c1>//条件成立：说明老表中的指定位置 有数据
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                    <span class=c1>//获取entry#key
</span><span class=c1></span>                    <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
                    <span class=c1>//条件成立：说明老表中的当前位置的entry 是一个过期数据..
</span><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                        <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// Help the GC
</span><span class=c1></span>                    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
                        <span class=c1>//执行到这里，说明老表的当前位置的元素是非过期数据 正常数据，需要迁移到扩容后的新表。。
</span><span class=c1></span>
                        <span class=c1>//计算出当前entry在扩容后的新表的 存储位置。
</span><span class=c1></span>                        <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>k</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>newLen</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
                        <span class=c1>//while循环 就是拿到一个距离h最近的一个可以使用的slot。
</span><span class=c1></span>                        <span class=k>while</span> <span class=o>(</span><span class=n>newTab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
                            <span class=n>h</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>newLen</span><span class=o>);</span>

                        <span class=c1>//将数据存放到 新表的 合适的slot中。
</span><span class=c1></span>                        <span class=n>newTab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                        <span class=c1>//数量+1
</span><span class=c1></span>                        <span class=n>count</span><span class=o>++;</span>
                    <span class=o>}</span>
                <span class=o>}</span>
            <span class=o>}</span>


            <span class=c1>//设置下一次触发扩容的指标。
</span><span class=c1></span>            <span class=n>setThreshold</span><span class=o>(</span><span class=n>newLen</span><span class=o>);</span>
            <span class=n>size</span> <span class=o>=</span> <span class=n>count</span><span class=o>;</span>
            <span class=c1>//将扩容后的新表 的引用保存到 threadLocalMap 对象的 table这里。。
</span><span class=c1></span>            <span class=n>table</span> <span class=o>=</span> <span class=n>newTab</span><span class=o>;</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div><h4 id=remove>remove()</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>()</span> <span class=o>{</span>
         <span class=c1>//获取当前线程的 threadLocalMap对象
</span><span class=c1></span>         <span class=n>ThreadLocalMap</span> <span class=n>m</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>());</span>
         <span class=c1>//条件成立：说明当前线程已经初始化过 threadLocalMap对象了
</span><span class=c1></span>         <span class=k>if</span> <span class=o>(</span><span class=n>m</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
             <span class=c1>//调用threadLocalMap.remove( key = 当前threadLocal)
</span><span class=c1></span>             <span class=n>m</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
     <span class=o>}</span>
<span class=kd>private</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
            <span class=c1>// 算出 下标 查询到key相同 主动清理软引用
</span><span class=c1></span>            <span class=c1>// 并执行一次  探测式清理
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
            <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
                 <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
                 <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>)])</span> <span class=o>{</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
                    <span class=n>e</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
                    <span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
                    <span class=k>return</span><span class=o>;</span>
                <span class=o>}</span>
            <span class=o>}</span>
        <span class=o>}</span>
</code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/threadlocal/>ThreadLocal</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/threadpoolexecutor%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/ class=prev rel=prev title=ThreadPoolExecutor源码学习><i class="fas fa-angle-left fa-fw"></i>ThreadPoolExecutor源码学习</a>
<a href=/synchronousqueue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/ class=next rel=next title=SynchronousQueue源码学习>SynchronousQueue源码学习<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><script src=https://fastly.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script><link rel=stylesheet href=https://fastly.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://fastly.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>yakax</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://fastly.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://fastly.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"yakax.blog","id-2":"yakax.blog"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"ZV0KOOHDR2","algoliaIndex":"blog","algoliaSearchKey":"18786e4380343a0db3412c6f2338c32c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":150,"type":"algolia"},"typeit":{"cursorChar":"_","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":200}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>